@()(implicit request: play.api.mvc.Request[Any])
<!DOCTYPE html>


<html>
    <head>
        @head("GMQL")
        @*My less*@
    <link rel="stylesheet" href="@routes.Assets.at("stylesheets/login.css")">
    <link rel="stylesheet" href="@routes.Assets.at("stylesheets/main.css")">
    <link rel="stylesheet" href="@routes.Assets.at("stylesheets/tree.css")">
    <script src="@routes.Assets.at("javascripts/metadata.js")" type="text/javascript"></script>
    <script src="@routes.Assets.at("javascripts/file_upload.js")" type="text/javascript"></script>
    <script src="@routes.Assets.at("javascripts/query.js")" type="text/javascript"></script>
        @if(play.Play.isDev()) {
            <script src="@routes.Assets.at("javascripts/tree_dev.js")" type="text/javascript"></script>
        }


    </head>
    <body data-spy="scroll" data-target=".bs-docs-sidebar">
        <div>@views.html.gmql.gmql_navbar()</div>
        <div>@views.html.gmql.register_modal()</div>

            <!-- Main Content -->
        <div class="row MainContent">
                <!--Side Nav Bar -->
            <nav class="col-xs-3 bs-docs-sidebar">
                <ul id="sidebar" class="nav nav-stacked fixed">
                    <li>
                        <a href="#x1-20001" id="QQ2-1-2">Introduction and Motivations</a>
                    </li>
                    <li>
                        <a href="#x1-30002" id="QQ2-1-3">Region-based Data Model with Metadata</a>
                        <ul class="nav nav-stacked">
                            <li><a href="#x1-40002.1" id="QQ2-1-4">Motivation</a></li>
                            <li><a href="#x1-50002.2" id="QQ2-1-5">Definition</a></li>
                            <li><a href="#x1-60002.3" id="QQ2-1-6">Examples</a></li>
                        </ul>
                    </li>
                    <li>
                        <a href="#x1-70003" id="QQ2-1-9">GenoMetric Query Language</a>

                    </li>
                    <li>
                        <a href="#GroupA">Group A</a>
                        <ul class="nav nav-stacked">
                            <li><a href="#GroupASub1">Sub-Group 1</a></li>
                            <li><a href="#GroupASub2">Sub-Group 2</a></li>
                        </ul>
                    </li>
                    <li>
                        <a href="#GroupB">Group B</a>
                        <ul class="nav nav-stacked">
                            <li><a href="#GroupBSub1">Sub-Group 1</a></li>
                            <li><a href="#GroupBSub2">Sub-Group 2</a></li>
                        </ul>
                    </li>
                    <li>
                        <a href="#GroupC">Group C</a>
                        <ul class="nav nav-stacked">
                            <li><a href="#GroupCSub1">Sub-Group 1</a></li>
                            <li><a href="#GroupCSub2">Sub-Group 2</a></li>
                        </ul>
                    </li>
                </ul>
            </nav>

                <!--Main Content -->
            <div class="col-xs-9">
                <div class="maketitle">
                    <h2 class="titleHead">Specification of GMQL Version 2</h2>
                    <div class="author" ><span
                    class="cmr-12">Bio-Informatics Group, DEIB, Politecnico di Milano</span></div><br />
                    <div class="date" ><span
                    class="cmr-12">20/09/2016</span></div>
                </div>

                    <!--l. 42--><p class="indent" >


            </p>
                <h3 class="sectionHead"><span class="titlemark">1   </span> <a
                id="x1-20001"></a>Introduction and Motivations</h3>
                    <!--l. 46--><p class="noindent" >
                A new technology for reading the DNA, called Next Generation Sequencing (NGS),
                is changing biological research and will change medical practice, thanks to the
                low-cost availability of millions of whole genome sequences of a variety of species,
                and most important of humans. Huge repositories of sequence information are being
                collected by large consortia of research laboratories by using NGS; among them,
                ENCODE <span class="cite">[<a
            href="#X[ENCODE]"
onmouseover="tex4ht.body = tex4ht.XjVVENCODEjVV;
tex4ht.caption = '[ENCODE]';
return overlib(tex4ht.body, FULLHTML);"
onmouseout="nd();"
            >12</a>]</span>, TCGA <span class="cite">[<a
            href="#X[TCGA]"
onmouseover="tex4ht.body = tex4ht.XjVVTCGAjVV;
tex4ht.caption = '[TCGA]';
return overlib(tex4ht.body, FULLHTML);"
onmouseout="nd();"
            >35</a>]</span>, the <span
            class="cmti-10x-x-109">1000 Genomes Project </span><span class="cite">[<a
            href="#X1000"
onmouseover="tex4ht.body = tex4ht.X1000;
tex4ht.caption = '1000';
return overlib(tex4ht.body, FULLHTML);"
onmouseout="nd();"
            >1</a>]</span> and the <span
            class="cmti-10x-x-109">100,000 Genomes</span>
                <span
                class="cmti-10x-x-109">
                    Project</span><span class="footnote-mark"><!--\def\jstoday{2016-09-20 18:01:00} \input onmouseover.4ht   <js>-->  <a
            href="#fn1x0" id="fn1x0-bk"
onmouseover="tex4ht.body = tex4ht.fn1x0;
tex4ht.caption = '1';
return overlib(tex4ht.body, FULLHTML);"
onmouseout="nd();"

            ><sup class="textsuperscript">1</sup></a></span><a
            id="x1-2001f1"></a>.
                These sequences can be assembled with specific experimental data produced at
                the various research or clinical centers, opening new opportunities for biological
                discovery and for personalized medicine.
            </p><!--l. 55--><p class="indent" >   Several organizations are considering genomics at a global level. <span
            class="cmti-10x-x-109">Global Alliance for genomics</span>
                <span
                class="cmti-10x-x-109">and Health</span><span class="footnote-mark"><a
                href="#fn2x0" id="fn2x0-bk"
onmouseover="tex4ht.body = tex4ht.fn2x0;
tex4ht.caption = '2';
return overlib(tex4ht.body, FULLHTML);"
onmouseout="nd();"

                ><sup class="textsuperscript">2</sup></a></span><a
                id="x1-2002f2"></a>
                is a large consortium of over 200 research institutions with the goal of
                supporting voluntary and secure sharing of genomic and clinical data;
                their work on data interoperability is producing a data conversion
                technology<span class="footnote-mark"><a
                href="#fn3x0" id="fn3x0-bk"
onmouseover="tex4ht.body = tex4ht.fn3x0;
tex4ht.caption = '3';
return overlib(tex4ht.body, FULLHTML);"
onmouseout="nd();"

                ><sup class="textsuperscript">3</sup></a></span><a
                id="x1-2003f3"></a>.
                <span
                class="cmti-10x-x-109">Google </span>recently provided an API to store, process, explore, and share
                DNA sequence reads, alignments, and variant calls, using Google&#8217;s cloud
                infrastructure<span class="footnote-mark"><a
                href="#fn4x0" id="fn4x0-bk"
onmouseover="tex4ht.body = tex4ht.fn4x0;
tex4ht.caption = '4';
return overlib(tex4ht.body, FULLHTML);"
onmouseout="nd();"

                ><sup class="textsuperscript">4</sup></a></span><a
                id="x1-2004f4"></a>.
                Parallel frameworks are used to support genomic computing, including <span
                class="cmti-10x-x-109">Vertica</span>
                (used by Broad Institute and NY Genome Center) and <span
                class="cmti-10x-x-109">SciDB </span>(used by NCBI for
                storing the data of the 1000 Genome project <span class="cite">[<a
                href="#X1000"
onmouseover="tex4ht.body = tex4ht.X1000;
tex4ht.caption = '1000';
return overlib(tex4ht.body, FULLHTML);"
onmouseout="nd();"
                >1</a>]</span>).
            </p><!--l. 58--><p class="indent" >
                So far, the bio-informatics research community has been mostly challenged by
                <span
                class="cmti-10x-x-109">primary analysis </span>(production of sequences in the form of shorts DNA
                segments, or &#8221;reads&#8221;) and <span
            class="cmti-10x-x-109">secondary analysis </span>(alignment of reads to a
                reference genome and search for specific features, such as variants/mutations
                and peaks of expression); but the most important emerging problem is
                the so-called <span
            class="cmti-10x-x-109">tertiary analysis</span>, concerned with multi-sample processing,
                annotation and filtering of variants, and genome browser-driven exploratory
                analysis <span class="cite">[<a
            href="#X[Paradigm4]"
onmouseover="tex4ht.body = tex4ht.XjVVParadigm4jVV;
tex4ht.caption = '[Paradigm4]';
return overlib(tex4ht.body, FULLHTML);"
onmouseout="nd();"
            >25</a>]</span>. While secondary analysis targets <span
            class="cmti-10x-x-109">raw data </span>in output from
                NGS processors by using specialized methods, tertiary analysis targets
                <span
                class="cmti-10x-x-109">processed data </span>in output from secondary analysis and is responsible of <span
            class="cmti-10x-x-109">sense</span>
                <span
                class="cmti-10x-x-109">making</span>, e.g., discovering how heterogeneous regions interact with each
                other.
            </p><!--l. 68--><p class="indent" >   The <span
            class="cmbx-10x-x-109">GenData 2020 </span>research project was conceived to address
                this challenge, by enabling queries and analysis of processed genomic
                data<span class="footnote-mark"><a
            href="#fn5x0" id="fn5x0-bk"
onmouseover="tex4ht.body = tex4ht.fn5x0;
tex4ht.caption = '5';
return overlib(tex4ht.body, FULLHTML);"
onmouseout="nd();"

            ><sup class="textsuperscript">5</sup></a></span><a
            id="x1-2005f5"></a>.


                The project&#8217;s main results so far are a <span
            class="cmti-10x-x-109">Genomic Data Mode</span>l (GDM), which
                encodes processed data in terms of their regions and metadata, and a
                <span
                class="cmti-10x-x-109">GenoMetric Query Language </span>(GMQL) for extracting regions of interest
                from experiments and for computing their properties, with high-level
                operations for manipulating regions and for measuring their distances
                <span class="cite">[<a
                href="#X[GMQL]"
onmouseover="tex4ht.body = tex4ht.XjVVGMQLjVV;
tex4ht.caption = '[GMQL]';
return overlib(tex4ht.body, FULLHTML);"
onmouseout="nd();"
                >20</a>]</span>.
            </p><!--l. 75--><p class="indent" >
                The most relevant and, to the best of our knowledge, original aspects of
                <span
                class="cmbx-10x-x-109">GenData 2020 </span>
                is the targeting of the project towards heterogeneous processed
                data rather than raw data. World-wide genomic repositories already contain huge
                amounts of processed data, and actually their value stems from the certification
                of high-quality processing. While processed data are much smaller than raw data,
                they can be considered as &#8220;big data&#8221;, because each processed file can contain
                thousands or even millions of genomic regions. In the <span
            class="cmbx-10x-x-109">GenData 2020 </span>repository
                structure, we show that thousands of files can be extracted from the repositories
                and organized within one dataset, that can be simply referenced by name in
                GMQL.
            </p><!--l. 84--><p class="indent" >   Another unique aspect of <span
            class="cmbx-10x-x-109">GenData 2020 </span>is the inclusion of metadata in the
                GDM model and of metadata management in the GMQL query language.
                Each dataset includes in its metadata all known information about each
                sample (from the sample&#8217;s preparation up to the patient&#8217;s phenotype.)
                GMQL progressively computes both the regions and the metadata of
                resulting samples. Thus, result samples of every query carry their meta-data,
                linking them to their contributing input samples, as an indication of <span
            class="cmbx-10x-x-109">data</span>
                <span
                class="cmbx-10x-x-109">provenance</span>; this is very powerful, e.g. for building genotype-phenotype
                associations.
            </p><!--l. 93--><p class="indent" >   The <span
            class="cmbx-10x-x-109">GenData 2020 </span>implementation uses cloud computing. Specifically,
                Version 1 of the system, developed between 2013 and 2014, translates
                GMQL to Pig <span class="cite">[<a
            href="#X[Pig-APACHE]"
onmouseover="tex4ht.body = tex4ht.XjVVPigJjVAPACHEjVV;
tex4ht.caption = '[Pig-APACHE]';
return overlib(tex4ht.body, FULLHTML);"
onmouseout="nd();"
            >6</a>]</span> in the context of Hadoop 1 HDFS, while Version 2 of the
                system, developed in 2015, uses the Spark <span class="cite">[<a
            href="#X[Spark-APACHE]"
onmouseover="tex4ht.body = tex4ht.XjVVSparkJjVAPACHEjVV;
tex4ht.caption = '[Spark-APACHE]';
return overlib(tex4ht.body, FULLHTML);"
onmouseout="nd();"
            >7</a>]</span> and Flink <span class="cite">[<a
            href="#X[Flink-APACHE]"
onmouseover="tex4ht.body = tex4ht.XjVVFlinkJjVAPACHEjVV;
tex4ht.caption = '[Flink-APACHE]';
return overlib(tex4ht.body, FULLHTML);"
onmouseout="nd();"
            >4</a>]</span> frameworks as
                supported within Hadoop YARN <span class="cite">[<a
            href="#X[Hadoop 2]"
onmouseover="tex4ht.body = tex4ht.XjVVHadoop2jVV;
tex4ht.caption = '[Hadoop 2]';
return overlib(tex4ht.body, FULLHTML);"
onmouseout="nd();"
            >16</a>]</span>; the need of cloud architectures for
                genomics is advocated by <span class="cite">[<a
            href="#XNEW"
onmouseover="tex4ht.body = tex4ht.XNEW;
tex4ht.caption = 'NEW';
return overlib(tex4ht.body, FULLHTML);"
onmouseout="nd();"
            >30</a>]</span>. The expressive power and flexibility of
                GenData 2020&#8217;s data model (GDM) and query language (GMQL) are
                demonstrated in <span class="cite">[<a
            href="#X[GMQL]"
onmouseover="tex4ht.body = tex4ht.XjVVGMQLjVV;
tex4ht.caption = '[GMQL]';
return overlib(tex4ht.body, FULLHTML);"
onmouseout="nd();"
            >20</a>]</span>, where we show four very different genomic use
                cases<span class="footnote-mark"><a
            href="#fn6x0" id="fn6x0-bk"
onmouseover="tex4ht.body = tex4ht.fn6x0;
tex4ht.caption = '6';
return overlib(tex4ht.body, FULLHTML);"
onmouseout="nd();"

            ><sup class="textsuperscript">6</sup></a></span><a
            id="x1-2006f6"></a>. GenData
                2020 focuses on tertiary data analysis; a similar approach is advocated by <span
            class="cmti-10x-x-109">Paradigm4</span>, a
                company <span class="footnote-mark"><a
            href="#fn7x0" id="fn7x0-bk"
onmouseover="tex4ht.body = tex4ht.fn7x0;
tex4ht.caption = '7';
return overlib(tex4ht.body, FULLHTML);"
onmouseout="nd();"

            ><sup class="textsuperscript">7</sup></a></span><a
            id="x1-2007f7"></a>
                whose products include genomic adds-on to SciDB <span class="cite">[<a
                href="#X[Paradigm4]"
onmouseover="tex4ht.body = tex4ht.XjVVParadigm4jVV;
tex4ht.caption = '[Paradigm4]';
return overlib(tex4ht.body, FULLHTML);"
onmouseout="nd();"
                >25</a>]</span>. They also concentrate on
                the <span
                class="cmti-10x-x-109">tertiary analysis</span>
                , but they advocate the use of specialized databases rather
                than cloud computing.


            </p><!--l. 107--><p class="noindent" >
            </p>
                <h3 class="sectionHead"><span class="titlemark">2   </span> <a
                id="x1-30002"></a>Region-based Data Model with Metadata</h3>
                    <!--l. 109--><p class="noindent" >
                The Genomic Data Model (GDM) is based on the notions of datasets and
                samples; datasets are collections of samples, and each sample consists
                of two parts, the <span
            class="cmti-10x-x-109">region data</span>, which describe portions of the DNA and
                their features, and the <span
            class="cmti-10x-x-109">metadata</span>, which describe general properties of the
                sample.
            </p><!--l. 113--><p class="noindent" >
            </p><section
            id="x1-40002.1">
                <h4 class="subsectionHead"><span class="titlemark">2.1   </span> Motivation</h4>
                    <!--l. 115--><p class="noindent" >
                Processed data have a variety of file formats, and typically lack an attribute-based
                organization. GDM provides a schema to regions, thus it makes data
                self-describing, as advocated by Jim Gray <span class="cite">[<a
            href="#X[Gray]"
onmouseover="tex4ht.body = tex4ht.XjVVGrayjVV;
tex4ht.caption = '[Gray]';
return overlib(tex4ht.body, FULLHTML);"
onmouseout="nd();"
            >15</a>]</span>; however, we don&#8217;t include data
                into a database, so as to preserve the possibility for biologists to work with their
                usual file-based tools.
            </p><!--l. 120--><p class="indent" >
                The schema has a fixed part that guarantees the comparability of regions produced
                by different kinds of processing, and then a variable part describing the features
                produced by the various kinds of processing. Although DNA regions are strings of
                nucleotides<span class="footnote-mark"><a
            href="#fn8x0" id="fn8x0-bk"
onmouseover="tex4ht.body = tex4ht.fn8x0;
tex4ht.caption = '8';
return overlib(tex4ht.body, FULLHTML);"
onmouseout="nd();"

            ><sup class="textsuperscript">8</sup></a></span><a
            id="x1-4001f8"></a>,
                we instead associate them with a list of one or more <span
            class="cmti-10x-x-109">features</span>, where each feature
                is produced by secondary data analysis.
            </p><!--l. 128--><p class="indent" >
                Due to the lack of agreed standards for metadata, we model them as free
                attribute-value pairs; we expect metadata to include at least the experiment
                type, the sequencing and analysis method used for data production, the cell line,
                tissue, experimental condition (e.g., antibody target) and organism sequenced; in
                case of clinical studies, individual&#8217;s descriptions including phenotypes. Attributes
                may have multiple values (e.g., the <span
            class="cmtt-10x-x-109">Disease </span>attribute can have both
                values <span
            class="cmtt-10x-x-109">&#8217;Cancer&#8217; </span>and <span
            class="cmtt-10x-x-109">&#8217;Diabetes&#8217;</span>). Hundreds of datasets and thousands of
                samples<span class="footnote-mark"><a
            href="#fn9x0" id="fn9x0-bk"
onmouseover="tex4ht.body = tex4ht.fn9x0;
tex4ht.caption = '9';
return overlib(tex4ht.body, FULLHTML);"
onmouseout="nd();"

            ><sup class="textsuperscript">9</sup></a></span><a
            id="x1-4002f9"></a>
                can be queried thanks to the GDM model.
            </p><!--l. 136--><p class="noindent" >
            </p>
                </section>
                <h4 class="subsectionHead"><span class="titlemark">2.2   </span> <a
                id="x1-50002.2"></a>Definition</h4>
                    <!--l. 139--><p class="noindent" >A <span
            class="cmti-10x-x-109">genomic region </span><span
            class="cmmi-10x-x-109">r </span>is a portion of the genome defined by the quadruple of values


                <span
                class="cmmi-10x-x-109">&#x003C; chr,left,right,strand &#x003E;</span>, called <span
                class="cmbx-10x-x-109">region coordinates</span>, where <span
                class="cmmi-10x-x-109">chr </span>is the
                chromosome, <span
                class="cmmi-10x-x-109">left </span>and <span
                class="cmmi-10x-x-109">right </span>are the two ends of the region along the DNA
                coordinates<span class="footnote-mark"><a
                href="#fn10x0" id="fn10x0-bk"
onmouseover="tex4ht.body = tex4ht.fn10x0;
tex4ht.caption = '10';
return overlib(tex4ht.body, FULLHTML);"
onmouseout="nd();"

                ><sup class="textsuperscript">10</sup></a></span><a
                id="x1-5001f10"></a>;
                <span
                class="cmmi-10x-x-109">strand </span>represents the direction of DNA
                reading<span class="footnote-mark"><a
                href="#fn11x0" id="fn11x0-bk"
onmouseover="tex4ht.body = tex4ht.fn11x0;
tex4ht.caption = '11';
return overlib(tex4ht.body, FULLHTML);"
onmouseout="nd();"

                ><sup class="textsuperscript">11</sup></a></span><a
                id="x1-5002f11"></a>,
                encoded as either + or <span
                class="cmsy-10x-x-109">-</span>, and can be missing (encoded as
                <span
                class="cmsy-10x-x-109">*</span>)<span class="footnote-mark"><a
                href="#fn12x0" id="fn12x0-bk"
onmouseover="tex4ht.body = tex4ht.fn12x0;
tex4ht.caption = '12';
return overlib(tex4ht.body, FULLHTML);"
onmouseout="nd();"

                ><sup class="textsuperscript">12</sup></a></span><a
                id="x1-5003f12"></a>.
                Formally, a <span
                class="cmbx-10x-x-109">sample </span><span
                class="cmmi-10x-x-109">s </span>is a triple <span
                class="cmmi-10x-x-109">&#x003C; id,R,M &#x003E; </span>where: </p>
                <ul class="itemize1">
                    <li class="itemize"><span
                    class="cmmi-10x-x-109">id </span>is the sample identifier of type <span
                    class="cmtt-10x-x-109">long</span>.
                    </li>
                    <li class="itemize"><span
                    class="cmmi-10x-x-109">R </span>is  the  set  of  regions  of  the  sample,  built  as  pairs  <span
                    class="cmmi-10x-x-109">&#x003C;  c,f  &#x003E; </span>of
                        <span
                        class="cmbx-10x-x-109">coordinates </span><span
                        class="cmmi-10x-x-109">c </span>and <span
                        class="cmbx-10x-x-109">features </span><span
                        class="cmmi-10x-x-109">f</span>; coordinates are records of four fixed
                        attributes <span
                        class="cmtt-10x-x-109">chr, left, right, strand </span>which are respectively typed
                        <span
                        class="cmtt-10x-x-109">string, long, long, char</span>
                        ; features are records of typed attributes;
                        we assume attribute names of features to be different, and their types
                        to be any of <span
                        class="cmtt-10x-x-109">char, string, int, long, double, Boolean </span>(GDM
                        types are available both in Java, Scala, and in the Flink, Spark and Pig
                        frameworks). The <span
                        class="cmtt-10x-x-109">region schema </span>of <span
                        class="cmmi-10x-x-109">s </span>is the list of attribute names
                        used for the identifier, the coordinates and the features.
                    </li>
                    <li class="itemize"><span
                    class="cmmi-10x-x-109">M </span>is the set of metadata of the sample, built as attribute-value pairs
                        <span
                        class="cmmi-10x-x-109">&#x003C; a,v &#x003E;</span>, where we assume the type of each value <span
                        class="cmmi-10x-x-109">v </span>to be <span
                        class="cmtt-10x-x-109">string</span>.
                        The same attribute name <span
                        class="cmmi-10x-x-109">a </span>can appear in multiple pairs of the same
                        sample (in which case, we say that <span
                        class="cmmi-10x-x-109">a </span>is multi-valued).</li></ul>
                    <!--l. 168--><p class="noindent" >A <span
            class="cmbx-10x-x-109">dataset </span>is a collection of samples with the same region schema and with
                features having the same types; sample identifiers are unique within each
                dataset.
            </p><!--l. 171--><p class="noindent" >
            </p>
                <h4 class="subsectionHead"><span class="titlemark">2.3   </span> <a
                id="x1-60002.3"></a>Examples</h4>
                    <!--l. 173--><p class="noindent" >Each dataset is stored within <span
            class="cmbx-10x-x-109">GenData 2020 </span>using two tables, one for regions
                and one for metadata; an example of the two tables for representing a particular
                experiment, called <span
            class="cmti-10x-x-109">ChIP-seq</span>, is shown in Fig. <a
            href="#x1-6002r1">1<!--tex4ht:ref: data --></a>. Note that the region value has an
                attribute <span
            class="cmtt-10x-x-109">p</span><span
            class="cmtt-10x-x-109">_value </span>of type <span
            class="cmtt-10x-x-109">real </span>(representing how significant is the calling of the


                peak of that genomic region in the ChIP-seq experiment); note also that
                the <span
            class="cmtt-10x-x-109">id </span>attribute is present in both tables; it provides a many-to-many
                connection between regions and metadata of a sample; e.g., sample 1 has 5
                regions and 4 metadata attributes, sample 2 has 4 regions and 3 metadata
                attributes<span class="footnote-mark"><a
            href="#fn13x0" id="fn13x0-bk"
onmouseover="tex4ht.body = tex4ht.fn13x0;
tex4ht.caption = '13';
return overlib(tex4ht.body, FULLHTML);"
onmouseout="nd();"

            ><sup class="textsuperscript">13</sup></a></span><a
            id="x1-6001f13"></a>.
                The regions of the two samples are within chromosomes 1 and 2 of the DNA, and
                both are not stranded.
            </p>
                <hr class="figure" /><div class="figure"
            >


                <a
                id="x1-6002r1"></a>


                    <!--l. 186--><p class="noindent" ><img
            src="sources/chipseq.png" alt="PIC"
            />
                <br /> </p><div class="caption"
            ><span class="id">Figure&#x00A0;1: </span><span
            class="content">Regions and metadata of a dataset consisting of two samples.</span></div><!--tex4ht:label?: x1-6002r1 -->


            </div><hr class="endfigure" />
                    <!--l. 192--><p class="indent" >
                While the above example is simple, GDM supports the schema encoding of
                any processed data type, e.g., files for mutations, ChIP-seq, DNA-seq, RNA-seq,
                ChIA-PET, VCF, and SAM/BAM formats. We use GDM also for modeling
                <span
                class="cmbx-10x-x-109">annotations</span>, i.e. regions of the genome with known properties (such as
                genes, with their exons and introns). Schema encodings and one exemplar
                instance of DNA-seq and RNA-seq data samples are described in Fig.
                <a
                href="#x1-6003r2">2<!--tex4ht:ref: schemas --></a>.
            </p>
                <hr class="figure" /><div class="figure"
            >


                <a
                id="x1-6003r2"></a>


                <div class="verbatim" id="verbatim-1">
                    DNA-seq&#x00A0;(MUTATIONS)
                    &#x00A0;<br />(id,&#x00A0;(chr,left,right,strand),
                    &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;(A,&#x00A0;G,&#x00A0;C,&#x00A0;T,&#x00A0;del,&#x00A0;ins,&#x00A0;inserted,&#x00A0;ambiguous,
                    &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;Max,&#x00A0;Error,&#x00A0;A2T,&#x00A0;A2C,&#x00A0;A2G,&#x00A0;C2A,&#x00A0;C2G,&#x00A0;C2T))
                    &#x00A0;<br />(1,&#x00A0;(chr1,&#x00A0;917179,&#x00A0;917180,&#x00A0;*),
                    &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;(0,&#x00A0;0,&#x00A0;0,&#x00A0;0,&#x00A0;1,&#x00A0;0,&#x00A0;&#8217;.&#8217;,&#x00A0;&#8217;.&#8217;,
                    &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;0,&#x00A0;0,&#x00A0;0,&#x00A0;0,&#x00A0;0,&#x00A0;0,&#x00A0;0,&#x00A0;0))
                    &#x00A0;<br />
                        &#x00A0;<br />RNA-seq&#x00A0;(GENE&#x00A0;EXPRESSIONS)
                    &#x00A0;<br />(id,&#x00A0;(chr,left,right,strand),&#x00A0;(source,&#x00A0;type,&#x00A0;score,
                    &#x00A0;<br />&#x00A0;&#x00A0;frame,&#x00A0;geneID,&#x00A0;transcriptID,&#x00A0;RPKM1,&#x00A0;RPKM2,&#x00A0;iIDR))
                    &#x00A0;<br />(1,&#x00A0;(chr8,&#x00A0;101960824,&#x00A0;101964847,&#x00A0;*),
                    &#x00A0;<br />&#x00A0;(&#8217;GencodeV10&#8217;,&#x00A0;&#8217;transcript&#8217;,&#x00A0;0.026615,&#x00A0;NULL,
                    &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#8217;ENSG00000164924.11&#8217;,&#x00A0;&#8217;ENST00000418997.1&#8217;,
                    &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;0.209968,&#x00A0;0.193078,&#x00A0;0.058))
                </div>
                    <!--l. 215--><p class="nopar" >
                <br /> </p><div class="caption"
            ><span class="id">Figure&#x00A0;2: </span><span
            class="content">Examples of schema with one instance for two different types of
                processed data; coordinates and features are enclosed within two records.</span></div><!--tex4ht:label?: x1-6003r2 -->


            </div><hr class="endfigure" />
                <h3 class="sectionHead"><span class="titlemark">3   </span> <a
                id="x1-70003"></a>GenoMetric Query Language</h3>
                    <!--l. 233--><p class="noindent" >
                A GMQL query (or program) is expressed as a sequence of GMQL operations
                with the following structure:


            </p>
                <div class="verbatim" id="verbatim-2">
                        &#x003C;variable&#x003E;&#x00A0;=&#x00A0;operation(&#x003C;parameters&#x003E;)&#x00A0;&#x003C;variables&#x003E;
                </div>
                    <!--l. 236--><p class="nopar" >
                where each variable stands for a GDM dataset. Operations are either unary
                (with one input variable), or binary (with two input variables), and construct one
                result variable.
            </p><!--l. 241--><p class="noindent" >
            </p>
                <h4 class="subsectionHead"><span class="titlemark">3.1   </span> <a
                id="x1-80003.1"></a>General Properties</h4>
                    <!--l. 243--><p class="noindent" >
                GMQL operations form a closed algebra: results are expressed as new datasets
                derived from their operands. All operations produce a result dataset consisting of
                several samples, whose identifiers are either inherited by the operands or
                generated by the operation. Each operation separately applies to metadata and
                to regions; the region-based part of an operation computes the result regions, the
                metadata part of the operation computes the associated metadata so as to
                trace the provenance of each resulting sample; identifiers preserve the
                many-to-many mapping of regions and metadata as discussed in Section
                <a
                href="#x1-60002.3">2.3<!--tex4ht:ref: encodings --></a>.
            </p><!--l. 251--><p class="indent" >   Most GMQL operations, although defined upon two connected data
                structures, are extension of classic relational algebra operations, twisted to the
                needs of genomics; they are denoted as <span
            class="cmti-10x-x-109">relational</span>. Three domain-specific
                operations, called <span
            class="cmtt-10x-x-109">COVER</span>, (distal) <span
            class="cmtt-10x-x-109">JOIN </span>and <span
            class="cmtt-10x-x-109">MAP</span>, significantly extend the
                expressive power of classic relational algebra.
            </p><!--l. 257--><p class="indent" >   The main design principles of GMQL are <span
            class="cmti-10x-x-109">relational completeness </span>and
                <span
                class="cmti-10x-x-109">orthogonality</span>
                . Completeness is guaranteed by the fact that classical algebraic
                manipulations are all supported, suitably extended and adapted to comply with
                region-based calculus. Orthogonality is achieved because no operator can be
                defined as a suitable expression of all other operators; note that the classic
                abstractions of <span
                class="cmti-10x-x-109">grouping </span>is supported, with the same semantics, in the
                unary operations <span
                class="cmtt-10x-x-109">GROUP </span>and <span
                class="cmtt-10x-x-109">COVER</span>, and similarly <span
                class="cmti-10x-x-109">joining </span>is supported,
                with the same semantics, in the binary operations <span
                class="cmtt-10x-x-109">JOIN</span>, <span
                class="cmtt-10x-x-109">MAP</span>, <span
                class="cmtt-10x-x-109">MERGE </span>and
                <span
                class="cmtt-10x-x-109">DIFFERENCE</span>.
            </p><!--l. 265--><p class="indent" >
                Compared with languages which are currently in use by the bioinformatic
                community, GMQL is <span
            class="cmti-10x-x-109">declarative </span>(it specifies the structure of the results, leaving


                its computation to each operation&#8217;s implementation) and <span
            class="cmti-10x-x-109">high-level </span>(one GMQL
                query typically substitutes for a long program which embeds calls to
                region manipulation libraries); the progressive computation of variables
                resembles other algebraic languages (e.g. <span
            class="cmti-10x-x-109">Pig Latin</span>, <span class="cite">[<a
            href="#X[Pig-APACHE]"
onmouseover="tex4ht.body = tex4ht.XjVVPigJjVAPACHEjVV;
tex4ht.caption = '[Pig-APACHE]';
return overlib(tex4ht.body, FULLHTML);"
onmouseout="nd();"
            >6</a>]</span>). For all these
                features, GMQL may inspire a change of paradigm in genomics, along
                a direction that was indicated long ago by Edward T. Codd&#8217;s seminal
                papers.
            </p><!--l. 273--><p class="noindent" >
            </p>
                <h4 class="subsectionHead"><span class="titlemark">3.2   </span> <a
                id="x1-90003.2"></a>Predicates Evaluation</h4>
                    <!--l. 275--><p class="noindent" >
                Parameters of several operations include predicates, used to select and join
                samples; predicates are built by arbitrary Boolean expressions of simple
                predicates, as it is customary in relational algebra. The region attributes can
                refer positionally to the schema, i.e., <span
            class="cmtt-10x-x-109">$0 </span>denotes the first attribute <span
            class="cmtt-10x-x-109">$1</span>to the
                second, and so on. Predicates are either evaluated in the context of regions or of
                metadata, as follows: </p>
                <ul class="itemize1">
                    <li class="itemize">Predicates  on  metadata  have  an  existential  interpretation  over
                        samples: they select the entire sample if it contains some metadata
                        attributes such that the predicate evaluation on their values is true.
                        Formally, for each sample, a simple predicate <span
                    class="cmmi-10x-x-109">p </span>expressed as (<span
                    class="cmmi-10x-x-109">A</span><span style="margin-left: 3.04076pt" class="tmspace"></span><span
                    class="cmmi-10x-x-109">comp</span><span style="margin-left: 3.04076pt" class="tmspace"></span><span
                    class="cmmi-10x-x-109">V </span>)
                        on metadata <span
                    class="cmmi-10x-x-109">M </span>is defined as:
                        <!--l. 287--><p class="noindent" >
                    </p>
                        <center class="math-display" >
                            <img
                            src="manual1x.png" alt="p &#x21D0; &#x21D2; &#x2203;(a,v ) &#x2208; M : (a = A)&#x2227; (v compV )
         i i         i         i
     " class="math-display" /></center>
                            <!--l. 289--><p class="noindent" >
                            When a predicate on metadata uses an attribute which is missing, the
                            predicate is <span
                        class="cmtt-10x-x-109">unknown</span>; we use three-value (i.e. <span
                        class="cmtt-10x-x-109">true</span>, <span
                        class="cmtt-10x-x-109">false</span>, <span
                        class="cmtt-10x-x-109">unknown</span>)


                            logic for metadata predicates <span
                        class="cmmi-10x-x-109">p</span>, and we select samples <span
                        class="cmmi-10x-x-109">s </span>for which
                            <span
                            class="cmmi-10x-x-109">p</span>(<span
                        class="cmmi-10x-x-109">s</span>)  is  <span
                        class="cmtt-10x-x-109">true </span>given  the  above  interpretation.  The  special  predicate
                            <span
                            class="cmti-10x-x-109">missing(A) </span>is <span
                        class="cmtt-10x-x-109">true </span>if the attribute <span
                        class="cmmi-10x-x-109">A </span>is not present in <span
                        class="cmmi-10x-x-109">M</span>.
                        </p></li>
                    <li class="itemize">Predicates  on  regions  have  a  classic  interpretation:  they  select  the
                        regions where the predicate is true. Legal predicates must use the
                        attributes in the region&#8217;s schema; when a predicate is illegal, the query
                        is also illegal, and compilation fails.<span class="footnote-mark"><a
                    href="#fn14x0" id="fn14x0-bk"
onmouseover="tex4ht.body = tex4ht.fn14x0;
tex4ht.caption = '14';
return overlib(tex4ht.body, FULLHTML);"
onmouseout="nd();"

                    ><sup class="textsuperscript">14</sup></a></span><a
                    id="x1-9001f14"></a>
                        The evaluation of predicates involving two or more regions (essentially
                        join predicates) is defined only when regions have compatible strands;
                        positive  and  negative  strands  are  incompatible,  but  they  are  both
                        compatible with a missing strand.</li></ul>
                    <!--l. 303--><p class="noindent" >
            </p>
                <h4 class="subsectionHead"><span class="titlemark">3.3   </span> <a
                id="x1-100003.3"></a>Sintactic Conventions</h4>
                    <!--l. 305--><p class="noindent" >Operations have the general syntax:


            </p>
                <div class="verbatim" id="verbatim-3">
                    OUT=OPERATOR(parm-1;..parm-N&#x00A0;[;&#x00A0;n-parm-1]..[;n-parm-M])&#x00A0;IN-1&#x00A0;[IN-2];
                </div>
                    <!--l. 308--><p class="nopar" > Where </p>
                <ul class="itemize1">
                    <li class="itemize">All operations produce an output <span
                    class="cmtt-10x-x-109">OUT</span>; unari operations apply to a
                        single dataset <span
                    class="cmtt-10x-x-109">(IN-1)</span>, binary operations apply to two datasets (<span
                    class="cmtt-10x-x-109">IN-1</span>
                        and <span
                        class="cmtt-10x-x-109">IN-2</span>).
                    </li>
                    <li class="itemize"><span
                    class="cmtt-10x-x-109">parm </span>denotes  default  unnamed  parameters  for  the  <span
                    class="cmtt-10x-x-109">OPERATOR</span>.  The
                        semantic of these parameters is inferred from their position.
                    </li>
                    <li class="itemize"><span
                    class="cmtt-10x-x-109">n-parm</span>: optional parameters that have to be specified in the form of
                        pairs <span
                    class="cmtt-10x-x-109">name: value</span>. The semantics of each one of these parameters is
                        inferred from its name, therefore their position is irrelevant.</li></ul>
                    <!--l. 317--><p class="noindent" >Attributes exist in metadata and regiopns, denoted as follows: </p>
                <ul class="itemize1">
                    <li class="itemize"><span
                    class="cmtt-10x-x-109">&#x003C;attribute-name&#x003E;: any-string(.any-string)*   </span>
                        for   a   generic
                        metadata attribute name.
                    </li>
                    <li class="itemize"><span
                    class="cmtt-10x-x-109">&#x003C;field-name&#x003E; : any-string(.any-string)*    </span>
                        for     a     generic
                        attribute in the region schema.</li></ul>
                    <!--l. 322--><p class="noindent" >The prefix <span
            class="cmtt-10x-x-109">list </span>denotes a comma-separated list of elements, e.g. <span
            class="cmtt-10x-x-109">&#x003C;list-field-name&#x003E;</span>
                or <span
                class="cmtt-10x-x-109">&#x003C;list-attribute-name&#x003E;</span>
                . For what concerns case sensitivity: </p>
                <ul class="itemize1">
                    <li class="itemize">Region and field names are case sensitive: e.g. <span
                    class="cmtt-10x-x-109">pvalue != pValue !=</span>
                        <span
                        class="cmtt-10x-x-109">PVALUE</span>
                    </li>
                    <li class="itemize">GMQL keywords are not case sensitive: e.g. <span
                    class="cmtt-10x-x-109">UPSTREAM == upstream</span>
                        <span
                        class="cmtt-10x-x-109">==UpStReAm</span></li></ul>


                    <!--l. 329--><p class="noindent" >
            </p>
                <h3 class="sectionHead"><span class="titlemark">4   </span> <a
                id="x1-110004"></a>Relational GMQL Operations</h3>
                    <!--l. 331--><p class="noindent" >
                We next describe relational operations; they include six unary operations
                (<span
            class="cmtt-10x-x-109">SELECT</span>, <span
            class="cmtt-10x-x-109">PROJECT</span>, <span
            class="cmtt-10x-x-109">EXTEND</span>, <span
            class="cmtt-10x-x-109">MERGE</span>, <span
            class="cmtt-10x-x-109">GROUP </span>and <span
            class="cmtt-10x-x-109">SORT</span>) and two binary operations
                (<span
            class="cmtt-10x-x-109">UNION </span>and <span
            class="cmtt-10x-x-109">DIFFERENCE</span>).
            </p><!--l. 334--><p class="noindent" >
            </p>
                <h4 class="subsectionHead"><span class="titlemark">4.1   </span> <a
                id="x1-120004.1"></a>Select</h4>


                <div class="verbatim" id="verbatim-4">
                        &#x003C;S2&#x003E;&#x00A0;=&#x00A0;SELECT([&#x003C;pm&#x003E;][;][region:&#x00A0;&#x003C;pr&#x003E;][;][semijoin:&#x00A0;&#x003C;ps&#x003E;])&#x00A0;&#x003C;S1&#x003E;;
                </div>
                    <!--l. 338--><p class="nopar" > where: </p>
                <ul class="itemize1">
                    <li class="itemize"><span
                    class="cmtt-10x-x-109">&#x003C;pm&#x003E;</span>
                        :   Expression   whose   atomic   predicates   are   in   the   form:
                        <span
                        class="cmtt-10x-x-109">attribute-name  </span>(==   <span
                        class="cmsy-10x-x-109">| </span><span
                        class="cmmi-10x-x-109">&#x003E;   </span><span
                        class="cmsy-10x-x-109">| </span><span
                        class="cmmi-10x-x-109">&#x003C;   </span><span
                        class="cmsy-10x-x-109">| </span><span
                        class="cmmi-10x-x-109">&#x003E;</span>=   <span
                        class="cmsy-10x-x-109">| </span><span
                        class="cmmi-10x-x-109">&#x003C;</span>=)   <span
                        class="cmtt-10x-x-109">(value |</span>
                        <span
                        class="cmtt-10x-x-109">decimalNumber)</span>
                        .  Atomic  predicates  are  concatenated  by  means  of
                        the  OR,  AND  and  NOT  operators;  e.g.  <span
                        class="cmtt-10x-x-109">antibody==CTCF AND NOT</span>
                        <span
                        class="cmtt-10x-x-109">(weight &#x003E; 100 OR disease == cancer)</span>.
                    </li>
                    <li class="itemize"><span
                    class="cmtt-10x-x-109">&#x003C;pr&#x003E;</span>
                        : Expression whose atomic predicates are in the form: <span
                        class="cmtt-10x-x-109">field-name</span>
                        (==  <span
                        class="cmsy-10x-x-109">| </span><span
                        class="cmmi-10x-x-109">&#x003E;  </span><span
                        class="cmsy-10x-x-109">| </span><span
                        class="cmmi-10x-x-109">&#x003C;  </span><span
                        class="cmsy-10x-x-109">| </span><span
                        class="cmmi-10x-x-109">&#x003E;</span>=  <span
                        class="cmsy-10x-x-109">| </span><span
                        class="cmmi-10x-x-109">&#x003C;</span>=)  <span
                        class="cmtt-10x-x-109">(value | decimalNumber)</span>.  Atomic
                        predicates  are  concatenated  by  means  of  the  OR,  AND  and  NOT
                        operators; e.g. <span
                        class="cmtt-10x-x-109">pvalue &#x003C; 0.001 OR label==promoter</span>
                    </li>
                    <li class="itemize"><span
                    class="cmtt-10x-x-109">&#x003C;ps&#x003E;</span>: Semi-join expression in the form: <span
                    class="cmtt-10x-x-109">&#x003C;list-attribute-name&#x003E; IN</span>
                        <span
                        class="cmtt-10x-x-109">&#x003C;dataset&#x003E;</span>; e.g. <span
                        class="cmtt-10x-x-109">antibody,cell,treatment NOT IN HG</span><span
                        class="cmtt-10x-x-109">_BROAD</span></li></ul>
                    <!--l. 348--><p class="indent" >
                It keeps in the result all the samples which existentially satisfy the predicate
                on metadata <span
            class="cmtt-10x-x-109">&#x003C;pm&#x003E; </span>
                and then selects those regions of selected samples which satisfy
                the predicate on regions <span
            class="cmtt-10x-x-109">&#x003C;pr&#x003E;</span>; a sample is legal also when it contains no regions
                as result of a selection. Identifiers of selected samples of the operand <span
            class="cmmi-10x-x-109">S</span>1 are
                assigned to the result <span
            class="cmmi-10x-x-109">S</span>2.
            </p><!--l. 353--><p class="indent" >   <span
            class="cmtt-10x-x-109">Semi-join </span>clauses are used to further select samples; they have the syntax:
                <span
                class="cmtt-10x-x-109">&#x003C;A1&#x003E;..&#x003C;An&#x003E; IN &#x003C;extV&#x003E;</span>
                . Each attribute occurrence <span
                class="cmtt-10x-x-109">Ai </span>corresponds to a predicate
                <span
                class="cmmi-10x-x-109">p</span>(<span
                class="cmmi-10x-x-109">a</span><sub><span
                class="cmmi-8">i</span></sub><span
                class="cmmi-10x-x-109">,a</span><sub><span
                class="cmmi-8">j</span></sub>), where <span
                class="cmmi-10x-x-109">a</span><sub><span
                class="cmmi-8">i</span></sub> and <span
                class="cmmi-10x-x-109">a</span><sub><span
                class="cmmi-8">j</span></sub> are attributes with the same name. <span
                class="cmmi-10x-x-109">a</span><sub><span
                class="cmmi-8">i</span></sub> belongs to the
                schema of <span
                class="cmtt-10x-x-109">A</span>, <span
                class="cmmi-10x-x-109">a</span><sub><span
                class="cmmi-8">j</span></sub> to the schema of <span
                class="cmtt-10x-x-109">extV</span>. The predicate is true for a given sample <span
                class="cmmi-10x-x-109">s</span><sub><span
                class="cmmi-8">i</span></sub>
                of <span
                class="cmmi-10x-x-109">S</span>1 with attribute <span
                class="cmmi-10x-x-109">a</span><sub><span
                class="cmmi-8">i</span></sub> iff there exists a sample in the variable denoted as
                <span
                class="cmtt-10x-x-109">extV </span>with an attribute <span
                class="cmmi-10x-x-109">a</span><sub><span
                class="cmmi-8">j</span></sub> and the two attributes <span
                class="cmmi-10x-x-109">a</span><sub><span
                class="cmmi-8">i</span></sub> and <span
                class="cmmi-10x-x-109">a</span><sub><span
                class="cmmi-8">j</span></sub> share at least
                one value. Formally, if <span
                class="cmmi-10x-x-109">M</span><sub><span
                class="cmmi-8">E</span></sub> denotes the metadata of samples of <span
                class="cmtt-10x-x-109">extV</span>,
                then:
            </p><!--l. 360--><p class="indent" >


            </p>
                <center class="math-display" >
                    <img
                    src="manual2x.png" alt="p(ai,aj) &#x21D0; &#x21D2; &#x2203; (ai,vi) &#x2208; Mi, (aj,vj) &#x2208; ME : vi = vj
" class="math-display" /></center>
                    <!--l. 362--><p class="noindent" >
                A semi-join clause can be constructed as the conjunction of the above simple
                metadata predicates that refer to the same variable <span
            class="cmtt-10x-x-109">extV</span>. Semi-joins are used to
                connect variables, e.g., in the example below:


            </p>
                <div class="verbatim" id="verbatim-5">
                    OUT&#x00A0;=&#x00A0;SELECT(semijoin:&#x00A0;antibody_target&#x00A0;IN&#x00A0;EXP2)&#x00A0;EXP1;
                </div>
                    <!--l. 368--><p class="nopar" > samples of <span
            class="cmtt-10x-x-109">EXP1 </span>are selected only if they have the same <span
            class="cmtt-10x-x-109">antibody</span><span
            class="cmtt-10x-x-109">_target </span>value
                as in at least one sample of <span
            class="cmtt-10x-x-109">EXP2</span>.
            </p><!--l. 373--><p class="noindent" >
            </p>
                <h4 class="subsectionHead"><span class="titlemark">4.2   </span> <a
                id="x1-130004.2"></a>Project</h4>


                <div class="verbatim" id="verbatim-6">
                        &#x003C;S2&#x003E;&#x00A0;=&#x00A0;PROJECT([&#x003C;Ar1&#x003E;&#x00A0;..&#x00A0;&#x003C;Arm&#x003E;]
                        &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;[;][metadata:&#x00A0;[&#x003C;Am1&#x003E;&#x00A0;..&#x00A0;&#x003C;Amn&#x003E;]
                    &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;[;][region_update:&#x00A0;&#x003C;Ur1&#x003E;&#x00A0;AS&#x00A0;&#x003C;f1&#x003E;,&#x00A0;..,&#x00A0;&#x003C;Urh&#x003E;&#x00A0;AS&#x00A0;&#x003C;fh&#x003E;]
                    &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;[;][metadata_update:&#x00A0;&#x003C;Um1&#x003E;&#x00A0;AS&#x00A0;&#x003C;h1&#x003E;,&#x00A0;..,&#x00A0;&#x003C;Umk&#x003E;&#x00A0;AS&#x00A0;&#x003C;fk&#x003E;])&#x00A0;&#x003C;S1&#x003E;;
                </div>
                    <!--l. 380--><p class="nopar" > It keeps in the result the metadata (<span
            class="cmtt-10x-x-109">Am</span>) and region (<span
            class="cmtt-10x-x-109">Ar</span>) attributes expressed as
                parameters<span class="footnote-mark"><a
            href="#fn15x0" id="fn15x0-bk"
onmouseover="tex4ht.body = tex4ht.fn15x0;
tex4ht.caption = '15';
return overlib(tex4ht.body, FULLHTML);"
onmouseout="nd();"

            ><sup class="textsuperscript">15</sup></a></span><a
            id="x1-13001f15"></a>.
                It can also be used to build new attributes as scalar expressions <span
            class="cmtt-10x-x-109">fi </span>(e.g.,
                for metadata the <span
            class="cmtt-10x-x-109">age </span>from the <span
            class="cmtt-10x-x-109">birthdate</span>; for regions, the <span
            class="cmtt-10x-x-109">length </span>of a
                region as the difference between its <span
            class="cmtt-10x-x-109">right </span>and <span
            class="cmtt-10x-x-109">left </span>ends). If the name of
                existing schema attributes are used, the operation updates region attributes
                to new values. Identifiers of the operand <span
            class="cmmi-10x-x-109">S</span>1 are assigned to the result
                <span
                class="cmtt-10x-x-109">S2</span>.
            </p><!--l. 393--><p class="noindent" >
            </p>
                <h4 class="subsectionHead"><span class="titlemark">4.3   </span> <a
                id="x1-140004.3"></a>Extend</h4>


                <div class="verbatim" id="verbatim-7">
                        &#x003C;S2&#x003E;&#x00A0;=&#x00A0;EXTEND(&#x003C;Am1&#x003E;&#x00A0;AS&#x00A0;&#x003C;g1&#x003E;,&#x00A0;..,&#x00A0;&#x003C;Amn&#x003E;&#x00A0;AS&#x00A0;&#x003C;gn&#x003E;)&#x00A0;&#x003C;S1&#x003E;;
                </div>
                    <!--l. 397--><p class="nopar" > It generates new metadata attributes <span
            class="cmtt-10x-x-109">Am </span>as result of aggregate functions <span
            class="cmtt-10x-x-109">g</span>
                applied to region attributes; aggregate functions are applied sample by sample,
                and resulting tuples are triples with the sample identifier, the attribute name <span
                class="cmtt-10x-x-109">Am</span>,
                and the computed aggregate value. The supported aggregate functions include
                <span
                class="cmtt-10x-x-109">COUNT </span>(with no argument), <span
                class="cmtt-10x-x-109">BAG </span>(applicable to attributes of any type) and <span
                class="cmtt-10x-x-109">SUM,</span>
                <span
                class="cmtt-10x-x-109">AVG, MIN, MAX, MEDIAN, STD </span>
                (applicable to attributes of numeric types). E.g.,
                in the example below:


            </p>
                <div class="verbatim" id="verbatim-8">
                    OUT&#x00A0;=&#x00A0;EXTEND(RegionCount&#x00A0;AS&#x00A0;COUNT,&#x00A0;MinP&#x00A0;AS&#x00A0;MIN(Pvalue))&#x00A0;EXP;
                </div>
                    <!--l. 407--><p class="nopar" > for each sample of <span
            class="cmtt-10x-x-109">EXP</span>, two new metadata attributes are computed,
                <span
                class="cmtt-10x-x-109">RegionCount </span>as the number of sample regions, and <span
                class="cmtt-10x-x-109">MinP </span>as the minimum <span
                class="cmtt-10x-x-109">Pvalue</span>
                of the sample regions.
            </p><!--l. 412--><p class="noindent" >
            </p>
                <h4 class="subsectionHead"><span class="titlemark">4.4   </span> <a
                id="x1-150004.4"></a>Group</h4>


                <div class="verbatim" id="verbatim-9">
                        &#x003C;S2&#x003E;&#x00A0;=&#x00A0;GROUP([&#x003C;Am1&#x003E;&#x00A0;..&#x00A0;&#x003C;Amn&#x003E;]
                        &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;[;][meta_aggregate:&#x00A0;&#x003C;Gm1&#x003E;&#x00A0;AS&#x00A0;&#x003C;g1&#x003E;,&#x00A0;..,&#x00A0;&#x003C;Gmn&#x003E;&#x00A0;AS&#x00A0;&#x003C;gn&#x003E;]
                    &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;[;][region_group:&#x00A0;&#x003C;Ar1&#x003E;&#x00A0;..&#x00A0;&#x003C;Arn&#x003E;]
                    &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;[;][region_aggregate:&#x00A0;&#x003C;Gr1&#x003E;&#x00A0;AS&#x00A0;&#x003C;g1&#x003E;,&#x00A0;..,&#x00A0;&#x003C;Grn&#x003E;&#x00A0;AS&#x00A0;&#x003C;gn&#x003E;])&#x00A0;&#x003C;S1&#x003E;;
                </div>
                    <!--l. 419--><p class="nopar" >
                It is used for grouping both regions and metadata according to distinct values of
                the grouping attributes. For what concerns metadata, each distinct value of the
                grouping attributes is associated with an output sample, with a new identifier
                explicitly created for that sample; samples having missing values for any of
                the grouping attributes are discarded. The metadata of output samples,
                each corresponding a to given group, are constructed as the union of
                metadata of all the samples contributing to that group; consequently,
                metadata include the attributes storing the grouping values, that are common
                to each sample in the group. New grouping attributes <span
            class="cmtt-10x-x-109">Gm </span>are added to
                output samples, storing the results of aggregate function evaluations over
                each group. Examples of typical metadata grouping attributes are the
                <span
                class="cmtt-10x-x-109">Classification </span>of patients (e.g., as cases or controls) or their <span
            class="cmtt-10x-x-109">Disease</span>
                values.
            </p><!--l. 433--><p class="indent" >
                When the grouping attribute is multi-valued, samples are partitioned by each
                subset of their distinct values (e.g., samples with a <span
            class="cmtt-10x-x-109">Disease </span>attribute set both to
                <span
                class="cmtt-10x-x-109">&#8217;Cancer&#8217; </span>and <span
            class="cmtt-10x-x-109">&#8217;Diabetes&#8217; </span>are within a group which is distinct from the groups
                of the samples with only one value, either <span
            class="cmtt-10x-x-109">&#8217;Cancer&#8217; </span>or <span
            class="cmtt-10x-x-109">&#8217;Diabetes&#8217;</span>). Formally,
                two samples <span
            class="cmmi-10x-x-109">s</span><sub><span
            class="cmmi-8">i</span></sub> and <span
            class="cmmi-10x-x-109">s</span><sub><span
            class="cmmi-8">j</span></sub> belong to the same group, denoted as <span
            class="cmmi-10x-x-109">s</span><sub><span
            class="cmmi-8">i</span></sub><span
            class="cmmi-10x-x-109">&#x03B3;</span><sub><span
            class="cmmi-8">A</span></sub><span
            class="cmmi-10x-x-109">s</span><sub><span
            class="cmmi-8">j</span></sub>, if and only if
                they have exactly the same set of values for every grouping attribute A,
                i.e.
            </p>
                <center class="math-display" >
                    <img
                    src="manual3x.png" alt="s &#x03B3; s &#x21D0; &#x21D2;  {v|&#x2203; (A, v) &#x2208; M } = {v|&#x2203;(A, v) &#x2208; M }
 i A j                  i                 j " class="math-display" /></center>
                Given this definition, grouping has important properties:


                <ul class="itemize1">
                    <li class="itemize">reflexive: <span
                    class="cmmi-10x-x-109">s</span><sub><span
                    class="cmmi-8">i</span></sub><span
                    class="cmmi-10x-x-109">&#x03B3;</span><sub><span
                    class="cmmi-8">A</span></sub><span
                    class="cmmi-10x-x-109">s</span><sub><span
                    class="cmmi-8">i</span></sub>
                    </li>
                    <li class="itemize">commutative: <span
                    class="cmmi-10x-x-109">s</span><sub><span
                    class="cmmi-8">i</span></sub><span
                    class="cmmi-10x-x-109">&#x03B3;</span><sub><span
                    class="cmmi-8">A</span></sub><span
                    class="cmmi-10x-x-109">s</span><sub><span
                    class="cmmi-8">j</span></sub><span style="margin-left: 3.04076pt" class="tmspace"></span><span
                    class="cmsy-10x-x-109">&#x21D0;&#x21D2;</span><span style="margin-left: 3.04076pt" class="tmspace"></span><span
                    class="cmmi-10x-x-109">s</span><sub><span
                    class="cmmi-8">j</span></sub><span
                    class="cmmi-10x-x-109">&#x03B3;</span><sub><span
                    class="cmmi-8">A</span></sub><span
                    class="cmmi-10x-x-109">s</span><sub><span
                    class="cmmi-8">i</span></sub>
                    </li>
                    <li class="itemize">transitive: <span
                    class="cmmi-10x-x-109">s</span><sub><span
                    class="cmmi-8">i</span></sub><span
                    class="cmmi-10x-x-109">&#x03B3;</span><sub><span
                    class="cmmi-8">A</span></sub><span
                    class="cmmi-10x-x-109">s</span><sub><span
                    class="cmmi-8">j</span></sub> <span
                    class="cmsy-10x-x-109">&#x2227; </span><span
                    class="cmmi-10x-x-109">s</span><sub><span
                    class="cmmi-8">k</span></sub><span
                    class="cmmi-10x-x-109">&#x03B3;</span><sub><span
                    class="cmmi-8">A</span></sub><span
                    class="cmmi-10x-x-109">s</span><sub><span
                    class="cmmi-8">i</span></sub><span style="margin-left: 3.04076pt" class="tmspace"></span><span
                    class="cmsy-10x-x-109">&#x21D0;&#x21D2;</span><span style="margin-left: 3.04076pt" class="tmspace"></span><span
                    class="cmmi-10x-x-109">s</span><sub><span
                    class="cmmi-8">k</span></sub><span
                    class="cmmi-10x-x-109">&#x03B3;</span><sub><span
                    class="cmmi-8">A</span></sub><span
                    class="cmmi-10x-x-109">s</span><sub><span
                    class="cmmi-8">j</span></sub></li></ul>
                    <!--l. 449--><p class="noindent" >
                When grouping applies to regions, by default it includes the grouping attributes
                <span
                class="cmtt-10x-x-109">chr, left, right, strand</span>; this choice corresponds to the biological
                application of removing <span
            class="cmti-10x-x-109">duplicate regions</span>, i.e. regions with the same coordinates,
                possibly resulting from other operations, and ensures that the result
                is a legal GDM instance. Other attributes may be added to grouping
                attributes (e.g., <span
            class="cmtt-10x-x-109">RegionType</span>); aggregate functions can then be applied
                to each group. The resulting schema includes the attributes used for
                grouping and possibly new attributes used for the aggregate functions. The
                following example is used for calculating the minimum <span
            class="cmtt-10x-x-109">Pvalue </span>of duplicate
                regions:


            </p>
                <div class="verbatim" id="verbatim-10">
                    OUT&#x00A0;=&#x00A0;GROUP(Pvalue&#x00A0;AS&#x00A0;MIN(Pvalue))&#x00A0;EXP;
                </div>
                    <!--l. 459--><p class="nopar" >
            </p><!--l. 462--><p class="noindent" >
            </p>
                <h4 class="subsectionHead"><span class="titlemark">4.5   </span> <a
                id="x1-160004.5"></a>Merge</h4>


                <div class="verbatim" id="verbatim-11">
                        &#x003C;S2&#x003E;&#x00A0;=&#x00A0;MERGE&#x00A0;([groupby:&#x00A0;&#x003C;AM1&#x003E;,&#x00A0;..,&#x003C;AMn&#x003E;])&#x00A0;&#x003C;S1&#x003E;;
                </div>
                    <!--l. 466--><p class="nopar" >
                It builds a dataset consisting of a single sample having as regions all the regions
                of the input samples (without altering their coordinates, even when overlapping)
                and as metadata the union of all the attribute-values of the input samples. When
                a <span
            class="cmtt-10x-x-109">GROUPBY </span>clause is present, the samples are partitioned by groups, each with
                distinct values of grouping metadata attributes (i.e., homonym attributes in the
                operand schemas) and the merge operation is separately applied to each group,
                yielding to one sample in the result for each group, as discussed in Section
                <a
                href="#x1-150004.4">4.4<!--tex4ht:ref: grouping --></a>.
            </p><!--l. 475--><p class="noindent" >
            </p>
                <h4 class="subsectionHead"><span class="titlemark">4.6   </span> <a
                id="x1-170004.6"></a>Order</h4>


                <div class="verbatim" id="verbatim-12">
                        &#x003C;S2&#x003E;&#x00A0;=&#x00A0;ORDER([&#x003C;Am1&#x003E;&#x00A0;[DESC],&#x00A0;..,&#x00A0;&#x003C;Amn&#x003E;&#x00A0;[DESC]]
                        &#x00A0;<br />&#x00A0;&#x00A0;[;][meta_top:&#x00A0;&#x003C;k&#x003E;&#x00A0;|&#x00A0;[;]&#x00A0;meta_topg:&#x00A0;&#x003C;k&#x003E;]
                    &#x00A0;<br />&#x00A0;&#x00A0;[;][region_order:&#x00A0;&#x003C;Ar1&#x003E;&#x00A0;[DESC],&#x00A0;..,&#x00A0;&#x003C;Arn&#x003E;&#x00A0;[DESC]]
                    &#x00A0;<br />&#x00A0;&#x00A0;[;][region_top:&#x00A0;&#x003C;k&#x003E;&#x00A0;|&#x00A0;[;]&#x00A0;region_topg:&#x00A0;&#x003C;k&#x003E;])&#x00A0;&#x003C;S1&#x003E;;
                </div>
                    <!--l. 482--><p class="nopar" > It orders either samples, or regions, or both of them; order is <span
            class="cmti-10x-x-109">ascending </span>as
                default, and can be turned to <span
            class="cmti-10x-x-109">descending </span>by an explicit indication. Sorted
                samples or regions have a new attribute <span
            class="cmtt-10x-x-109">Order</span>, added to either metadata, or
                regions, or both of them; the value of <span
            class="cmtt-10x-x-109">Order </span>reflects the result of the sorting.
                Identifiers of the samples of the operand <span
            class="cmmi-10x-x-109">S</span>1 are assigned to the result <span
            class="cmmi-10x-x-109">S</span>2. The
                clause <span
            class="cmtt-10x-x-109">TOP &#x003C;k&#x003E; </span>extracts the first <span
            class="cmmi-10x-x-109">k </span>samples or regions, the clause <span
            class="cmtt-10x-x-109">TOPG &#x003C;k&#x003E;</span>
                implicitly considers the grouping by identical values of the first <span
                class="cmmi-10x-x-109">n </span><span
                class="cmsy-10x-x-109">- </span>1 ordering
                attributes and then selects the first <span
                class="cmmi-10x-x-109">k </span>samples or regions of each group. The
                operation:


            </p>
                <div class="verbatim" id="verbatim-13">
                    OUT&#x00A0;=&#x00A0;ORDER(RegionCount;&#x00A0;meta_top:&#x00A0;5;
                    &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;region_order:&#x00A0;MutationCount&#x00A0;DESC;&#x00A0;region_top:&#x00A0;7)&#x00A0;EXP;
                </div>
                    <!--l. 495--><p class="nopar" >
                extracts the first 5 samples on the basis of their region counter and then, for
                each of them, 7 regions on the basis of their mutation counter.
            </p><!--l. 500--><p class="noindent" >
            </p>
                <h4 class="subsectionHead"><span class="titlemark">4.7   </span> <a
                id="x1-180004.7"></a>Union</h4>


                <div class="verbatim" id="verbatim-14">
                        &#x003C;S3&#x003E;&#x00A0;=&#x00A0;UNION()&#x00A0;&#x003C;S1&#x003E;&#x00A0;&#x003C;S2&#x003E;;
                </div>
                    <!--l. 504--><p class="nopar" >
                It is used to integrate possibly heterogeneous samples of two datasets within a
                single dataset; each sample of both input datasets contributes to one sample of
                the result with identical metadata and merged region schema. New identifiers are
                assigned to each sample.
            </p><!--l. 509--><p class="indent" >
                Two region attributes are considered identical if they have the same name
                and type; the merging of two schemas is performed by projecting the schema of
                the second dataset over the schema of the first one. Fields of the first dataset
                which are missing in the second one are set to <span
            class="cmtt-10x-x-109">NULL </span>value, for all the regions of
                the second operator. For what concerns metadata, attributes are prefixed
                with the strings <span
            class="cmtt-10x-x-109">LEFT </span>or <span
            class="cmtt-10x-x-109">RIGHT </span>so as to trace the dataset to which they
                refer.
            </p><!--l. 516--><p class="noindent" >
            </p>
                <h4 class="subsectionHead"><span class="titlemark">4.8   </span> <a
                id="x1-190004.8"></a>Difference</h4>


                <div class="verbatim" id="verbatim-15">
                        &#x003C;S3&#x003E;&#x00A0;=&#x00A0;DIFFERENCE([joinby:&#x00A0;&#x003C;Att1&#x003E;,&#x00A0;..,&#x00A0;&#x003C;Attn&#x003E;])&#x00A0;&#x003C;S1&#x003E;&#x00A0;&#x003C;S2&#x003E;;
                </div>
                    <!--l. 520--><p class="nopar" >
                This operation produces a sample in the result for each sample of the first
                operand <span
            class="cmmi-10x-x-109">S</span>1, with identical identifier and metadata. It considers all the regions of
                the second operand, that we denote as <span
            class="cmti-10x-x-109">negative regions</span>; for each sample <span
            class="cmmi-10x-x-109">s</span>1 of <span
            class="cmmi-10x-x-109">S</span>1,
                it includes in the corresponding result sample those regions which do not
                intersect with any negative region.
            </p><!--l. 527--><p class="indent" >   When the <span
            class="cmtt-10x-x-109">JOINBY </span>clause is present, for each sample <span
            class="cmmi-10x-x-109">s</span>1 of the first dataset <span
            class="cmmi-10x-x-109">S</span>1
                we consider as negative regions only the regions of the samples <span
            class="cmmi-10x-x-109">s</span>2 of <span
            class="cmmi-10x-x-109">S</span>2 that
                satisfy the join condition. Syntactically, the clause consists of a list of attribute
                names, which are homonyms from the schemas of <span
            class="cmmi-10x-x-109">S</span>1 and of <span
            class="cmmi-10x-x-109">S</span>2; the strings <span
            class="cmtt-10x-x-109">LEFT</span>
                or <span
                class="cmtt-10x-x-109">RIGHT </span>that may be present as prefixes of attribute names as result of
                binary operators are not considered for detecting homonyms. We formally
                define a simple equi-join predicate <span
                class="cmmi-10x-x-109">a</span><sub><span
                class="cmmi-8">i</span></sub> == <span
                class="cmmi-10x-x-109">a</span><sub><span
                class="cmmi-8">j</span></sub>, but the generalization to
                conjunctions of simple predicates is straightforward. The predicate is true for
                given samples <span
                class="cmmi-10x-x-109">s</span>1 and <span
                class="cmmi-10x-x-109">s</span>2 iff the two attributes share at least one value,
                e.g.:
            </p><!--l. 537--><p class="indent" >
            </p>
                <center class="math-display" >
                    <img
                    src="manual4x.png" alt="p(ai,aj) &#x21D0; &#x21D2; &#x2203;(ai,vi) &#x2208; M1, (aj,vj) &#x2208; M2 : vi = vj
" class="math-display" /></center>
                    <!--l. 539--><p class="noindent" >The operation:


            </p>
                <div class="verbatim" id="verbatim-16">
                    OUT&#x00A0;=&#x00A0;DIFFERENCE(joinby:&#x00A0;antibody_target)&#x00A0;EXP1&#x00A0;EXP2;
                </div>
                    <!--l. 543--><p class="nopar" > extracts for every pair of samples <span
            class="cmmi-10x-x-109">s</span><sub><span
            class="cmr-8">1</span></sub><span
            class="cmmi-10x-x-109">,s</span><sub><span
            class="cmr-8">2</span></sub> of EXP1 and EXP2 having the same
                value of <span
            class="cmtt-10x-x-109">antibody</span><span
            class="cmtt-10x-x-109">_target </span>the regions that appear in <span
            class="cmmi-10x-x-109">s</span><sub><span
            class="cmr-8">1</span></sub> but not in <span
            class="cmmi-10x-x-109">s</span><sub><span
            class="cmr-8">2</span></sub>; metadata
                of the result are the same as the metadata of <span
            class="cmmi-10x-x-109">s</span><sub><span
            class="cmr-8">1</span></sub>.
            </p><!--l. 548--><p class="noindent" >
            </p>
                <h3 class="sectionHead"><span class="titlemark">5   </span> <a
                id="x1-200005"></a>Domain-Specific Operations</h3>
                    <!--l. 550--><p class="noindent" >We next focus on <span
            class="cmti-10x-x-109">domain-specific </span>operations, which are more specifically
                responding to genomic management requirements: the unary operation <span
            class="cmtt-10x-x-109">COVER</span>
                and the binary operations <span
                class="cmtt-10x-x-109">MAP </span>and <span
                class="cmtt-10x-x-109">JOIN</span>.
            </p><!--l. 560--><p class="noindent" >
            </p>
                <h4 class="subsectionHead"><span class="titlemark">5.1   </span> <a
                id="x1-210005.1"></a>Cover</h4>


                <div class="verbatim" id="verbatim-17">
                        &#x003C;S2&#x003E;&#x00A0;=&#x00A0;COVER/FLAT/SUMMIT/HISTOGRAM&#x00A0;(&#x003C;minAcc&#x003E;,&#x00A0;&#x003C;maxAcc&#x003E;
                        &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;[;&#x00A0;groupby:&#x00A0;&#x003C;Am1&#x003E;,&#x00A0;..,&#x00A0;&#x003C;Amn&#x003E;]
                    &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;[;&#x00A0;aggregate:&#x00A0;&#x003C;Ar1&#x003E;&#x00A0;AS&#x00A0;&#x003C;g1&#x003E;,&#x00A0;..,&#x00A0;&#x003C;Arn&#x003E;&#x00A0;AS&#x00A0;&#x003C;gn&#x003E;])&#x00A0;&#x003C;S1&#x003E;;
                </div>
                    <!--l. 566--><p class="nopar" > The <span
            class="cmtt-10x-x-109">COVER </span>operation responds to the need of computing properties that
                reflect region&#8217;s intersections, for example to compute a single sample from
                several samples which are replicas of the same experiment, or for dealing
                with overlapping regions (as, by construction, resulting regions are not
                overlapping.)
            </p><!--l. 573--><p class="indent" >   Let us initially consider the <span
            class="cmtt-10x-x-109">COVER </span>operation with no grouping; in such case,
                the operation produces a single output sample, and all the metadata
                attributes of the contributing input samples in <span
            class="cmmi-10x-x-109">S</span>1 are assigned to the
                resulting single sample <span
            class="cmmi-10x-x-109">s </span>in <span
            class="cmmi-10x-x-109">S</span>2. Regions of the result sample are built
                from the regions of samples in <span
            class="cmmi-10x-x-109">S</span>1 according to the following condition:
            </p>
                <ul class="itemize1">
                    <li class="itemize">Each resulting region <span
                    class="cmmi-10x-x-109">r </span>in <span
                    class="cmmi-10x-x-109">S</span>2 is the contiguous intersection of at least
                        <span
                        class="cmtt-10x-x-109">minAcc </span>and at most <span
                        class="cmtt-10x-x-109">maxAcc </span>contributing regions <span
                        class="cmmi-10x-x-109">r</span><sub><span
                        class="cmmi-8">i</span></sub> in the samples of
                        <span
                        class="cmmi-10x-x-109">S</span>1 <span class="footnote-mark"><a
                        href="#fn16x0" id="fn16x0-bk"
onmouseover="tex4ht.body = tex4ht.fn16x0;
tex4ht.caption = '16';
return overlib(tex4ht.body, FULLHTML);"
onmouseout="nd();"

                        ><sup class="textsuperscript">16</sup></a></span><a
                        id="x1-21001f16"></a>;
                        <span
                        class="cmtt-10x-x-109">minAcc </span>and <span
                        class="cmtt-10x-x-109">maxAcc </span>are called <span
                        class="cmbx-10x-x-109">accumulation indexes</span><span class="footnote-mark"><a
                        href="#fn17x0" id="fn17x0-bk"
onmouseover="tex4ht.body = tex4ht.fn17x0;
tex4ht.caption = '17';
return overlib(tex4ht.body, FULLHTML);"
onmouseout="nd();"

                        ><sup class="textsuperscript">17</sup></a></span><a
                        id="x1-21002f17"></a>.</li></ul>
                    <!--l. 590--><p class="noindent" >Resulting regions may have new attributes <span
            class="cmmi-10x-x-109">Ar</span>, calculated by means of
                aggregate expressions over the attributes of the contributing regions. <span
            class="cmtt-10x-x-109">Jaccard</span>
                <span
                class="cmtt-10x-x-109">Indexes</span><span class="footnote-mark"><a
                href="#fn18x0" id="fn18x0-bk"
onmouseover="tex4ht.body = tex4ht.fn18x0;
tex4ht.caption = '18';
return overlib(tex4ht.body, FULLHTML);"
onmouseout="nd();"

                ><sup class="textsuperscript">18</sup></a></span><a
                id="x1-21003f18"></a>
                are standard measures of similarity of the contributing regions <span
                class="cmmi-10x-x-109">r</span><sub><span
                class="cmmi-8">i</span></sub>, added as
                default region attributes. When a <span
                class="cmtt-10x-x-109">GROUPBY </span>clause is present, the samples are
                partitioned by groups, each with distinct values of grouping metadata attributes
                (i.e., homonym attributes in the operand schemas) and the cover operation is
                separately applied to each group, yielding to one sample in the result for each
                group, as discussed in Section <a
                href="#x1-150004.4">4.4<!--tex4ht:ref: grouping --></a>.
            </p><!--l. 599--><p class="noindent" >For what concerns variants: </p>
                <ul class="itemize1">
                    <li class="itemize"><span
                    class="cmtt-10x-x-109">FLAT </span>returns the union of all the regions which contribute to the <span
                    class="cmtt-10x-x-109">COVER</span>
                        (more precisely, it returns the contiguous region that starts from the
                        first end and stops at the last end of the regions which would contribute
                        to each region of the <span
                        class="cmtt-10x-x-109">COVER</span>).


                    </li>
                    <li class="itemize"><span
                    class="cmtt-10x-x-109">SUMMIT </span>returns only those portions of the result regions of the <span
                    class="cmtt-10x-x-109">COVER</span>
                        where  the  maximum  number  of  regions  intersect  (more  precisely,
                        it  returns  regions  that  start  from  a  position  where  the  number  of
                        intersecting regions is not increasing afterwards and stops at a position
                        where either the number of intersecting regions decreases, or it violates
                        the max accumulation index).
                    </li>
                    <li class="itemize"><span
                    class="cmtt-10x-x-109">HISTOGRAM </span>returns  the  nonoverlapping  regions  contributing  to  the
                        cover, each with its accumulation index value, which is assigned to the
                        <span
                        class="cmbx-10x-x-109">AccIndex </span>region attribute.</li></ul>
                <hr class="figure" /><div class="figure"
            >


                <a
                id="x1-21004r3"></a>


                    <!--l. 615--><p class="noindent" ><img
            src="manual5x.png" alt="PIC" class="graphics" /><!--tex4ht:graphics
name="manual5x.png" src="sources/cover2_2.PNG"
-->
                <br /> </p><div class="caption"
            ><span class="id">Figure&#x00A0;3: </span><span
            class="content">Accumulation index and <span
            class="cmtt-10x-x-109">COVER </span>results with three different <span
            class="cmtt-10x-x-109">minAcc</span>
                and <span
                class="cmtt-10x-x-109">maxAcc </span>values.</span></div><!--tex4ht:label?: x1-21004r3 -->


            </div><hr class="endfigure" />
                    <!--l. 620--><p class="noindent" ><span
            class="cmbx-10x-x-109">Example. </span>Fig. <a
            href="#x1-21004r3">3<!--tex4ht:ref: cover --></a> shows three applications of the <span
            class="cmtt-10x-x-109">COVER </span>operation on three
                samples, represented on a small portion of the genome; the figure shows the
                values of the accumulation index and then the regions resulting from
                setting the <span
            class="cmtt-10x-x-109">minAcc </span>and <span
            class="cmtt-10x-x-109">maxAcc </span>parameters respectively to (2<span
            class="cmmi-10x-x-109">,</span>2), (1<span
            class="cmmi-10x-x-109">,</span>2), and
                (2<span
            class="cmmi-10x-x-109">,</span>3).
            </p><!--l. 627--><p class="indent" >   The following <span
            class="cmtt-10x-x-109">COVER </span>operation produces output regions where at least 2 and
                at most 3 regions of <span
            class="cmtt-10x-x-109">EXP </span>overlap, having as resulting region attributes the min
                <span
                class="cmtt-10x-x-109">pValue </span>
                of the overlapping regions and their Jaccard indexes; the result has one
                sample for each input <span
                class="cmtt-10x-x-109">cell</span>.


            </p>
                <div class="verbatim" id="verbatim-18">
                    RES&#x00A0;=&#x00A0;COVER(2,&#x00A0;3;&#x00A0;groupby:&#x00A0;cell;&#x00A0;aggregate:
                    &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;pValue&#x00A0;AS&#x00A0;MIN(pValue))&#x00A0;EXP;
                </div>
                    <!--l. 633--><p class="nopar" >
            </p>
                <h4 class="subsectionHead"><span class="titlemark">5.2   </span> <a
                id="x1-220005.2"></a>Map</h4>


                <div class="verbatim" id="verbatim-19">
                        &#x003C;S3&#x003E;&#x00A0;=&#x00A0;MAP([&#x003C;Ar1&#x003E;&#x00A0;AS&#x00A0;&#x003C;g1&#x003E;,&#x00A0;..,&#x00A0;&#x003C;Arn&#x003E;&#x00A0;AS&#x00A0;&#x003C;gn&#x003E;]
                        &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;[;][joinby:&#x00A0;&#x003C;Am1&#x003E;,&#x00A0;..,&#x00A0;&#x003C;Amn&#x003E;])&#x00A0;&#x003C;S1&#x003E;&#x00A0;&#x003C;S2&#x003E;;
                </div>
                    <!--l. 640--><p class="nopar" >
            </p><!--l. 642--><p class="noindent" ><span
            class="cmtt-10x-x-109">MAP </span>is a binary operation over two datasets, respectively called <span
            class="cmbx-10x-x-109">reference</span>
                and <span
                class="cmbx-10x-x-109">experiment</span>. Let us consider one reference sample, with a set of
                reference regions; the operation computes, for each sample in the experiment,
                aggregates over the values of the experiment regions that intersect with each
                reference region; we say that <span
                class="cmti-10x-x-109">experiment regions are mapped to reference</span>
                <span
                class="cmti-10x-x-109">regions</span>. The operation produces a matrix structure, called <span
                class="cmbx-10x-x-109">genomic</span>
                <span
                class="cmbx-10x-x-109">space</span>, where each experiment sample is associated with a row, each
                reference region with a column, and each matrix row is a vector of
                numbers<span class="footnote-mark"><a
                href="#fn19x0" id="fn19x0-bk"
onmouseover="tex4ht.body = tex4ht.fn19x0;
tex4ht.caption = '19';
return overlib(tex4ht.body, FULLHTML);"
onmouseout="nd();"

                ><sup class="textsuperscript">19</sup></a></span><a
                id="x1-22001f19"></a>.
                Thus, a <span
                class="cmtt-10x-x-109">MAP </span>operation allows a quantitative reading of experiments with respect
                to the reference regions; when the biological function of the reference regions is
                not known, the <span
                class="cmtt-10x-x-109">MAP </span>helps in extracting the most interesting regions out of many
                candidates.
            </p><!--l. 656--><p class="indent" >   We first consider the basic <span
            class="cmtt-10x-x-109">MAP </span>operation, without <span
            class="cmtt-10x-x-109">JOINBY </span>clause. For a given
                reference sample <span
            class="cmmi-10x-x-109">s</span><sub><span
            class="cmr-8">1</span></sub>, let <span
            class="cmmi-10x-x-109">R</span><sub><span
            class="cmr-8">1</span></sub> be the set of its regions; for each sample <span
            class="cmmi-10x-x-109">s</span><sub><span
            class="cmr-8">2</span></sub> of the
                second operand, with <span
            class="cmmi-10x-x-109">s</span><sub><span
            class="cmr-8">2</span></sub> =<span
            class="cmmi-10x-x-109">&#x003C; id</span><sub><span
            class="cmr-8">2</span></sub><span
            class="cmmi-10x-x-109">,R</span><sub><span
            class="cmr-8">2</span></sub><span
            class="cmmi-10x-x-109">,M</span><sub><span
            class="cmr-8">2</span></sub> <span
            class="cmmi-10x-x-109">&#x003E; </span>(according to the GDM notation), the
                new sample <span
            class="cmmi-10x-x-109">s</span><sub><span
            class="cmr-8">3</span></sub> =<span
            class="cmmi-10x-x-109">&#x003C; id</span><sub><span
            class="cmr-8">3</span></sub><span
            class="cmmi-10x-x-109">,R</span><sub><span
            class="cmr-8">3</span></sub><span
            class="cmmi-10x-x-109">,M</span><sub><span
            class="cmr-8">3</span></sub> <span
            class="cmmi-10x-x-109">&#x003E; </span>is constructed; <span
            class="cmmi-10x-x-109">id</span><sub><span
            class="cmr-8">3</span></sub> is generated from <span
            class="cmmi-10x-x-109">id</span><sub><span
            class="cmr-8">1</span></sub> and
                <span
                class="cmmi-10x-x-109">id</span><sub><span
                class="cmr-8">2</span></sub><span class="footnote-mark"><a
                href="#fn20x0" id="fn20x0-bk"
onmouseover="tex4ht.body = tex4ht.fn20x0;
tex4ht.caption = '20';
return overlib(tex4ht.body, FULLHTML);"
onmouseout="nd();"

                ><sup class="textsuperscript">20</sup></a></span><a
                id="x1-22002f20"></a>,
                the metadata <span
                class="cmmi-10x-x-109">M</span><sub><span
                class="cmr-8">3</span></sub> are obtained by merging metadata <span
                class="cmmi-10x-x-109">M</span><sub><span
                class="cmr-8">1</span></sub> and <span
                class="cmmi-10x-x-109">M</span><sub><span
                class="cmr-8">2</span></sub>, and the
                regions <span
                class="cmmi-10x-x-109">R</span><sub><span
                class="cmr-8">3</span></sub> = <span
                class="cmsy-10x-x-109">{</span><span
                class="cmmi-10x-x-109">&#x003C; c</span><sub><span
                class="cmr-8">3</span></sub><span
                class="cmmi-10x-x-109">,f</span><sub><span
                class="cmr-8">3</span></sub> <span
                class="cmmi-10x-x-109">&#x003E;</span><span
                class="cmsy-10x-x-109">} </span>are created such that, for each region <span
                class="cmmi-10x-x-109">r</span><sub><span
                class="cmr-8">1</span></sub> <span
                class="cmsy-10x-x-109">&#x2208; </span><span
                class="cmmi-10x-x-109">R</span><sub><span
                class="cmr-8">1</span></sub>, there is
                exactly one region <span
                class="cmmi-10x-x-109">r</span><sub><span
                class="cmr-8">3</span></sub> <span
                class="cmsy-10x-x-109">&#x2208; </span><span
                class="cmmi-10x-x-109">R</span><sub><span
                class="cmr-8">3</span></sub>, having the same coordinates (i.e., <span
                class="cmmi-10x-x-109">c</span><sub><span
                class="cmr-8">3</span></sub> = <span
                class="cmmi-10x-x-109">c</span><sub><span
                class="cmr-8">1</span></sub>) and having
                as features <span
                class="cmmi-10x-x-109">f</span><sub><span
                class="cmr-8">3</span></sub> obtained as the concatenation of the features <span
                class="cmmi-10x-x-109">f</span><sub><span
                class="cmr-8">1</span></sub> and the new
                attributes computed by the aggregate functions <span
                class="cmmi-10x-x-109">g </span>specified in the operation; such
                aggregate functions are applied to the attributes of all the regions <span
                class="cmmi-10x-x-109">r</span><sub><span
                class="cmr-8">2</span></sub> <span
                class="cmsy-10x-x-109">&#x2208; </span><span
                class="cmmi-10x-x-109">R</span><sub><span
                class="cmr-8">2</span></sub> having
                a non-empty intersection with <span
                class="cmmi-10x-x-109">r</span><sub><span
                class="cmr-8">1</span></sub>. A default aggregate <span
                class="cmtt-10x-x-109">Count </span>counts the
                number of regions <span
                class="cmmi-10x-x-109">r</span><sub><span
                class="cmr-8">2</span></sub> <span
                class="cmsy-10x-x-109">&#x2208; </span><span
                class="cmmi-10x-x-109">R</span><sub><span
                class="cmr-8">2</span></sub> having a non-empty intersection with <span
                class="cmmi-10x-x-109">r</span><sub><span
                class="cmr-8">1</span></sub>. For
                each region, a field named <span
                class="cmtt-10x-x-109">count</span><span
                class="cmtt-10x-x-109">_LeftDSName</span><span
                class="cmtt-10x-x-109">_RighDSName </span>is added,
                storing the result of <span
                class="cmtt-10x-x-109">Count </span>aggregate. The operation is iterated for each
                reference sample, and generates a sample-specific genomic space at each
                iteration.
            </p><!--l. 675--><p class="indent" >   When the <span
            class="cmtt-10x-x-109">JOINBY </span>clause is present, for each sample <span
            class="cmmi-10x-x-109">s</span>1 of the first dataset <span
            class="cmmi-10x-x-109">S</span>1
                we consider the regions of the samples <span
            class="cmmi-10x-x-109">s</span>2 of <span
            class="cmmi-10x-x-109">S</span>2 that satisfy the join condition.
                Syntactically, the clause consists of a list of attribute names, which are


                homonyms from the schemas of S1 and of S2; the strings <span
            class="cmtt-10x-x-109">LEFT </span>or <span
            class="cmtt-10x-x-109">RIGHT </span>that may
                be present as prefixes of attribute names as result of binary operators are not
                considered for detecting homonyms.
            </p>
                <hr class="figure" /><div class="figure"
            >


                <a
                id="x1-22003r4"></a>


                    <!--l. 683--><p class="noindent" ><img
            src="manual6x.png" alt="PIC" class="graphics" /><!--tex4ht:graphics
name="manual6x.png" src="sources/map.PNG"
-->
                <br /> </p><div class="caption"
            ><span class="id">Figure&#x00A0;4: </span><span
            class="content">Example of map using one sample as reference and three samples
                as experiment, using the Count aggregate function. </span></div><!--tex4ht:label?: x1-22003r4 -->


            </div><hr class="endfigure" />
                    <!--l. 689--><p class="noindent" ><span
            class="cmbx-10x-x-109">Example. </span>Fig. <a
            href="#x1-22003r4">4<!--tex4ht:ref: map --></a> shows the effect of this <span
            class="cmtt-10x-x-109">MAP </span>operation on a small portion of the
                genome; the input consists of one reference sample with 3 regions and three
                mutation experiment samples, the output consists of three samples, each with the
                same regions as the reference sample, whose features corresponds to the number
                of mutations which intersect with those regions. The result can be interpreted as
                a (3 <span
            class="cmsy-10x-x-109">&#x00D7; </span>3) genome space.
            </p><!--l. 696--><p class="indent" >   In the example below, the <span
            class="cmtt-10x-x-109">MAP </span>operation counts how many mutations occur in
                known genes, where the dataset <span
            class="cmtt-10x-x-109">EXP </span>contains DNA mutation regions and <span
            class="cmtt-10x-x-109">GENES</span>
                contains the genes.


            </p>
                <div class="verbatim" id="verbatim-20">
                    RES&#x00A0;=&#x00A0;MAP()&#x00A0;GENES&#x00A0;EXP;
                </div>
                    <!--l. 700--><p class="nopar" >
            </p>
                <h4 class="subsectionHead"><span class="titlemark">5.3   </span> <a
                id="x1-230005.3"></a>Join</h4>


                <div class="verbatim" id="verbatim-21">
                        &#x003C;S3&#x003E;&#x00A0;=&#x00A0;JOIN([&#x003C;genometric-pred&#x003E;][;]&#x00A0;[output:&#x00A0;&#x003C;coord-gen&#x003E;]
                        &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;[;]&#x00A0;[joinby:&#x00A0;&#x003C;Am1&#x003E;,&#x00A0;..,&#x00A0;&#x003C;Amn&#x003E;])&#x00A0;&#x003C;S1&#x003E;&#x00A0;&#x003C;S2&#x003E;;
                </div>
                    <!--l. 707--><p class="nopar" >
            </p><!--l. 709--><p class="indent" >   The <span
            class="cmtt-10x-x-109">JOIN </span>operation applies to two datasets, respectively called <span
            class="cmbx-10x-x-109">anchor </span>(the
                first one) and <span
            class="cmbx-10x-x-109">experiment </span>(the second one), and acts in two phases (each of
                them can be missing). In the first phase, pairs of samples which satisfy
                the <span
            class="cmtt-10x-x-109">joinby </span>predicate (also called meta-join predicate) are identified;
                in the second phase, regions that satisfy the <span
            class="cmbx-10x-x-109">genometric predicate</span>
                are selected. The meta-join predicate allows selecting sample pairs with
                appropriate biological conditions (e.g., regarding the same cell line or
                antibody); syntactically, it is expressed as a list of homonym attributes from
                the schemes of <span
                class="cmtt-10x-x-109">S1 </span>and <span
                class="cmtt-10x-x-109">S2</span>, as previously. The genometric join predicate
                allows expressing a variety of distal conditions, needed by biologists.
                The anchor is used as startpoint in evaluating genometric predicates
                (which are not symmetric). The join result is constructed as follows:
            </p>
                <ul class="itemize1">
                    <li class="itemize">The meta-join predicates initially selects pairs <span
                    class="cmmi-10x-x-109">s</span><sub><span
                    class="cmr-8">1</span></sub> of <span
                    class="cmmi-10x-x-109">S</span>1 and <span
                    class="cmmi-10x-x-109">s</span><sub><span
                    class="cmr-8">2</span></sub> of <span
                    class="cmmi-10x-x-109">S</span>2
                        that satisfy the joinby condition. If the clause is omitted, then the
                        Cartesian product of all pairs <span
                    class="cmmi-10x-x-109">s</span><sub><span
                    class="cmr-8">1</span></sub> of <span
                    class="cmmi-10x-x-109">S</span>1 and <span
                    class="cmmi-10x-x-109">s</span><sub><span
                    class="cmr-8">2</span></sub> of <span
                    class="cmmi-10x-x-109">S</span>2 are selected. For
                        each such pair, a new sample <span
                    class="cmmi-10x-x-109">s</span><sub><span
                    class="cmr-8">12</span></sub> is generated in the result, having an
                        identifier <span
                    class="cmmi-10x-x-109">id</span><sub><span
                    class="cmr-8">12</span></sub>, generated from <span
                    class="cmmi-10x-x-109">id</span><sub><span
                    class="cmr-8">1</span></sub> and <span
                    class="cmmi-10x-x-109">id</span><sub><span
                    class="cmr-8">2</span></sub>, and metadata given by the
                        union of metadata of <span
                    class="cmmi-10x-x-109">s</span><sub><span
                    class="cmr-8">1</span></sub> and <span
                    class="cmmi-10x-x-109">s</span><sub><span
                    class="cmr-8">2</span></sub>.
                    </li>
                    <li class="itemize">Then, the genometric predicate is tested for all the pairs <span
                    class="cmmi-10x-x-109">&#x003C; r</span><sub><span
                    class="cmmi-8">i</span></sub><span
                    class="cmmi-10x-x-109">,r</span><sub><span
                    class="cmmi-8">j</span></sub> <span
                    class="cmmi-10x-x-109">&#x003E;</span>
                        of regions, with <span
                        class="cmmi-10x-x-109">r</span><sub><span
                        class="cmr-8">1</span></sub> <span
                        class="cmsy-10x-x-109">&#x2208; </span><span
                        class="cmmi-10x-x-109">s</span><sub><span
                        class="cmr-8">1</span></sub> and <span
                        class="cmmi-10x-x-109">r</span><sub><span
                        class="cmmi-8">j</span></sub> <span
                        class="cmsy-10x-x-109">&#x2208; </span><span
                        class="cmmi-10x-x-109">s</span><sub><span
                        class="cmr-8">2</span></sub>, by assigning the role of <span
                        class="cmbx-10x-x-109">anchor</span>
                        <span
                        class="cmbx-10x-x-109">region</span>,  in  turn,  to  all  the  regions  of  <span
                        class="cmmi-10x-x-109">s</span>1,  and  then  evaluating  the
                        genometric predicate condition with all the regions of <span
                        class="cmmi-10x-x-109">s</span>2. From every
                        pair  <span
                        class="cmmi-10x-x-109">&#x003C;  r</span><sub><span
                        class="cmmi-8">i</span></sub><span
                        class="cmmi-10x-x-109">,r</span><sub><span
                        class="cmmi-8">j</span></sub>  <span
                        class="cmmi-10x-x-109">&#x003E; </span>
                        that  satisfies  the  join  condition,  a  new  region  is
                        generated in <span
                        class="cmmi-10x-x-109">s</span><sub><span
                        class="cmr-8">12</span></sub>.</li></ul>
                    <!--l. 731--><p class="noindent" >
                From this description, it follows that the join operation yields results that can
                grow quadratically both in the number of samples and of regions; hence,
                it is the most critical GMQL operation from a computational point of
                view.


            </p><!--l. 736--><p class="indent" >   Genometric predicates are based on the <span
            class="cmbx-10x-x-109">genomic distance</span>, defined as the
                number of bases (i.e., nucleotides) between the closest opposite ends of two
                regions, measured from the right end of the region with left end lower
                coordinate.<span class="footnote-mark"><a
            href="#fn21x0" id="fn21x0-bk"
onmouseover="tex4ht.body = tex4ht.fn21x0;
tex4ht.caption = '21';
return overlib(tex4ht.body, FULLHTML);"
onmouseout="nd();"

            ><sup class="textsuperscript">21</sup></a></span><a
            id="x1-23001f21"></a>
                A genometric predicate is a sequence of distal conditions, defined as follows:
            </p>
                <ul class="itemize1">
                    <li class="itemize"><span
                    class="cmtt-10x-x-109">UP/DOWN</span><span class="footnote-mark"><a
                    href="#fn22x0" id="fn22x0-bk"
onmouseover="tex4ht.body = tex4ht.fn22x0;
tex4ht.caption = '22';
return overlib(tex4ht.body, FULLHTML);"
onmouseout="nd();"

                    ><sup class="textsuperscript">22</sup></a></span><a
                    id="x1-23002f22"></a>
                        denotes the <span
                        class="cmti-10x-x-109">upstream </span>and <span
                        class="cmti-10x-x-109">downstream </span>directions of the genome. They
                        are interpreted as predicates that must hold on the region <span
                        class="cmmi-10x-x-109">s</span><sub><span
                        class="cmr-8">2</span></sub>  of the
                        experiment; <span
                        class="cmtt-10x-x-109">UP </span>is true when <span
                        class="cmmi-10x-x-109">s</span><sub><span
                        class="cmr-8">2</span></sub> is in the <span
                        class="cmti-10x-x-109">upstream genome </span>of the anchor
                        region<span class="footnote-mark"><a
                        href="#fn23x0" id="fn23x0-bk"
onmouseover="tex4ht.body = tex4ht.fn23x0;
tex4ht.caption = '23';
return overlib(tex4ht.body, FULLHTML);"
onmouseout="nd();"

                        ><sup class="textsuperscript">23</sup></a></span><a
                        id="x1-23003f23"></a>.
                        When this clause is not present, distal conditions apply to both the
                        directions of the genome.
                    </li>
                    <li class="itemize"><span
                    class="cmtt-10x-x-109">MD(K)</span><span class="footnote-mark"><a
                    href="#fn24x0" id="fn24x0-bk"
onmouseover="tex4ht.body = tex4ht.fn24x0;
tex4ht.caption = '24';
return overlib(tex4ht.body, FULLHTML);"
onmouseout="nd();"

                    ><sup class="textsuperscript">24</sup></a></span><a
                    id="x1-23004f24"></a>
                        denotes the <span
                        class="cmti-10x-x-109">minimum distance </span>clause; it selects the <span
                        class="cmmi-10x-x-109">K </span>regions of the
                        experiment at minimal distance from the anchor region. When there
                        are ties (i.e., regions at the same distance from the anchor region),
                        regions of the experiment are kept in the result even if they exceed the
                        <span
                        class="cmmi-10x-x-109">K </span>limit.
                    </li>
                    <li class="itemize"><span
                    class="cmtt-10x-x-109">DLE(N)</span><span class="footnote-mark"><a
                    href="#fn25x0" id="fn25x0-bk"
onmouseover="tex4ht.body = tex4ht.fn25x0;
tex4ht.caption = '25';
return overlib(tex4ht.body, FULLHTML);"
onmouseout="nd();"

                    ><sup class="textsuperscript">25</sup></a></span><a
                    id="x1-23005f25"></a>
                        denotes the <span
                        class="cmti-10x-x-109">less-equal distance </span>clause; it selects all the regions of the
                        experiment such that their distance from the anchor region is less than
                        or equal to N bases<span class="footnote-mark"><a
                        href="#fn26x0" id="fn26x0-bk"
onmouseover="tex4ht.body = tex4ht.fn26x0;
tex4ht.caption = '26';
return overlib(tex4ht.body, FULLHTML);"
onmouseout="nd();"

                        ><sup class="textsuperscript">26</sup></a></span><a
                        id="x1-23006f26"></a>.
                    </li>
                    <li class="itemize"><span
                    class="cmtt-10x-x-109">DGE(N)</span><span class="footnote-mark"><a
                    href="#fn27x0" id="fn27x0-bk"
onmouseover="tex4ht.body = tex4ht.fn27x0;
tex4ht.caption = '27';
return overlib(tex4ht.body, FULLHTML);"
onmouseout="nd();"

                    ><sup class="textsuperscript">27</sup></a></span><a
                    id="x1-23007f27"></a>
                        denotes the <span
                        class="cmti-10x-x-109">greater-equal distance </span>clause; it selects all the regions of the
                        experiment such that their distance from the anchor region is greater
                        than or equal to N bases.</li></ul>
                    <!--l. 764--><p class="noindent" >
                Genometric clauses are composed by strings of distal conditions; we say that a
                genometric clause is <span
            class="cmbx-10x-x-109">well-formed </span>iff it includes the <span
            class="cmti-10x-x-109">less-equal distance </span>clause; we
                expect all clauses to be well formed, possibly because the clause <span
            class="cmtt-10x-x-109">DLE(Max) </span>is
                automatically added at the end of the string, where <span
            class="cmtt-10x-x-109">Max </span>is a problem-specific
                maximum distance.
            </p><!--l. 771--><p class="noindent" ><span
            class="cmbx-10x-x-109">Example. </span>The following strings are legal genometric predicates:


            </p>
                <div class="verbatim" id="verbatim-22">
                    DGE(500),&#x00A0;UP,&#x00A0;DLE(1000),&#x00A0;MD(1)
                    &#x00A0;<br />
                    DGE(50000),&#x00A0;UP,&#x00A0;DLE(100000),&#x00A0;(S1.left&#x00A0;-&#x00A0;S2.left&#x00A0;&#x003E;&#x00A0;600)
                    &#x00A0;<br />DLE(2000),&#x00A0;MD(1),&#x00A0;DOWN
                    &#x00A0;<br />MD(100),&#x00A0;DLE(3000)
                </div>
                    <!--l. 779--><p class="nopar" >
            </p><!--l. 781--><p class="noindent" >
                Note that different orderings of the same distal clauses may produce different
                results; this aspect has been designed in order to provide all the required
                biological meanings.
            </p>
                <hr class="figure" /><div class="figure"
            >


                <a
                id="x1-23008r5"></a>


                    <!--l. 787--><p class="noindent" ><img
            src="manual7x.png" alt="PIC" class="graphics" /><!--tex4ht:graphics
name="manual7x.png" src="sources/example_order.JPG"
-->
                <br /> </p><div class="caption"
            ><span class="id">Figure&#x00A0;5: </span><span
            class="content">Different semantics of genometric clauses due to the ordering of
                distal conditions; excluded regions are gray.</span></div><!--tex4ht:label?: x1-23008r5 -->


            </div><hr class="endfigure" />
                    <!--l. 792--><p class="noindent" ><span
            class="cmbx-10x-x-109">Examples. </span>In Fig. <a
            href="#x1-23008r5">5<!--tex4ht:ref: exampleorder --></a>
                we show an evaluation of the following two clauses relative
                to an anchor region: <span
                class="cmtt-10x-x-109">A: MD(1), DGE(100)</span>; <span
                class="cmtt-10x-x-109">B: DGE(100), MD(1)</span>. In case
                A, the <span
                class="cmtt-10x-x-109">MD(1) </span>clause is computed first, producing one region which is
                next excluded by computing the <span
                class="cmtt-10x-x-109">DGE(100) </span>clause; therefore, no region is
                produced. In case B, the <span
                class="cmtt-10x-x-109">DGE(100) </span>clause is computed first, producing two
                regions, and then the <span
                class="cmtt-10x-x-109">MD(1) </span>clause is computed, producing as result one
                region<span class="footnote-mark"><a
                href="#fn28x0" id="fn28x0-bk"
onmouseover="tex4ht.body = tex4ht.fn28x0;
tex4ht.caption = '28';
return overlib(tex4ht.body, FULLHTML);"
onmouseout="nd();"

                ><sup class="textsuperscript">28</sup></a></span><a
                id="x1-23009f28"></a>.
            </p><!--l. 803--><p class="indent" >   Similarly, the clauses <span
            class="cmtt-10x-x-109">A: MD(1), UP </span>and <span
            class="cmtt-10x-x-109">B: UP, MD(1) </span>may produce
                different results, as in case A the minimum distance region is selected regardless
                of streams and then retained iff it belongs to the upstream of the anchor, while in
                case B only upstream regions are considered, and the one at minimum distance is
                selected.
            </p><!--l. 808--><p class="indent" >   Next, we discuss the structure of resulting samples. Assume that
                regions <span
            class="cmmi-10x-x-109">r</span><sub><span
            class="cmmi-8">i</span></sub> of <span
            class="cmmi-10x-x-109">s</span><sub><span
            class="cmmi-8">i</span></sub> and <span
            class="cmmi-10x-x-109">r</span><sub><span
            class="cmmi-8">j</span></sub> of <span
            class="cmmi-10x-x-109">s</span><sub><span
            class="cmmi-8">j</span></sub> satisfy the genometric predicate, then a new
                region <span
            class="cmmi-10x-x-109">r</span><sub><span
            class="cmmi-8">ij</span></sub> is created, having merged features obtained by concatenating
                the feature attributes of the first dataset with the feature attributes of
                the second dataset as discussed in Section <a
            href="#x1-180004.7">4.7<!--tex4ht:ref: merge --></a>. The coordinates <span
            class="cmmi-10x-x-109">c</span><sub><span
            class="cmmi-8">ij</span></sub> are
                generated according to the <span
            class="cmtt-10x-x-109">coord-gen </span>clause, which has four options
                <span class="footnote-mark"><a
                href="#fn29x0" id="fn29x0-bk"
onmouseover="tex4ht.body = tex4ht.fn29x0;
tex4ht.caption = '29';
return overlib(tex4ht.body, FULLHTML);"
onmouseout="nd();"

                ><sup class="textsuperscript">29</sup></a></span><a
                id="x1-23010f29"></a>:
            </p><ol class="enumerate1" >
                <li
                class="enumerate" id="x1-23012x1"><span
                class="cmtt-10x-x-109">LEFT </span>assigns to <span
                class="cmmi-10x-x-109">r</span><sub><span
                class="cmmi-8">ij</span></sub> the coordinates <span
                class="cmmi-10x-x-109">c</span><sub><span
                class="cmmi-8">i</span></sub> of the anchor region.
                </li>
                <li
                class="enumerate" id="x1-23014x2"><span
                class="cmtt-10x-x-109">RIGHT </span>assigns to <span
                class="cmmi-10x-x-109">r</span><sub><span
                class="cmmi-8">ij</span></sub> the coordinates <span
                class="cmmi-10x-x-109">c</span><sub><span
                class="cmmi-8">j</span></sub> of the experiment region.
                </li>
                <li
                class="enumerate" id="x1-23016x3"><span
                class="cmtt-10x-x-109">INT </span>assigns to <span
                class="cmmi-10x-x-109">r</span><sub><span
                class="cmmi-8">ij</span></sub> the coordinates of the intersection of <span
                class="cmmi-10x-x-109">r</span><sub><span
                class="cmmi-8">i</span></sub> and <span
                class="cmmi-10x-x-109">r</span><sub><span
                class="cmmi-8">j</span></sub>; if
                    the intersection is empty then no region is produced.
                </li>
                <li
                class="enumerate" id="x1-23018x4"><span
                class="cmtt-10x-x-109">CAT </span>(also: <span
                class="cmtt-10x-x-109">CONTIG</span>) assigns to <span
                class="cmmi-10x-x-109">r</span><sub><span
                class="cmmi-8">ij</span></sub> the coordinates of the concatenation
                    of <span
                class="cmmi-10x-x-109">r</span><sub><span
                class="cmmi-8">i</span></sub> and <span
                class="cmmi-10x-x-109">r</span><sub><span
                class="cmmi-8">j</span></sub> (i.e., the region from the lower left end between those of
                    <span
                    class="cmmi-10x-x-109">r</span><sub><span
                    class="cmmi-8">i</span></sub> and <span
                    class="cmmi-10x-x-109">r</span><sub><span
                    class="cmmi-8">j</span></sub> to the upper right end between those of <span
                    class="cmmi-10x-x-109">r</span><sub><span
                    class="cmmi-8">i</span></sub> and <span
                    class="cmmi-10x-x-109">r</span><sub><span
                    class="cmmi-8">j</span></sub>).</li></ol>
                    <!--l. 824--><p class="noindent" ><span
            class="cmbx-10x-x-109">Example. </span>The following join searches for those regions of particular
                ChIP-seq experiments, called histone modifications (HM), that
                are at a minimal distance from the transcription start sites of
                genes (TSS), provided that such distance is greater than 120K
                bases<span class="footnote-mark"><a
            href="#fn30x0" id="fn30x0-bk"
onmouseover="tex4ht.body = tex4ht.fn30x0;
tex4ht.caption = '30';
return overlib(tex4ht.body, FULLHTML);"
onmouseout="nd();"

            ><sup class="textsuperscript">30</sup></a></span><a
            id="x1-23019f30"></a>.
                Note that the result uses the coordinates of the experiment.


            </p>
                <div class="verbatim" id="verbatim-23">
                    RES&#x00A0;=&#x00A0;JOIN(MD(1),&#x00A0;DGE(120000);&#x00A0;output:&#x00A0;RIGHT)&#x00A0;TSS&#x00A0;HM;
                </div>
                    <!--l. 832--><p class="nopar" >
            </p>
                <h3 class="sectionHead"><span class="titlemark">6   </span> <a
                id="x1-240006"></a>Utility Operations</h3>
                    <!--l. 837--><p class="noindent" >
            </p>
                <h4 class="subsectionHead"><span class="titlemark">6.1   </span> <a
                id="x1-250006.1"></a>Materialize</h4>


                <div class="verbatim" id="verbatim-24">
                    MATERIALIZE&#x00A0;&#x003C;S1&#x003E;&#x00A0;INTO&#x00A0;file_name;
                </div>
                    <!--l. 841--><p class="nopar" >
            </p><!--l. 843--><p class="indent" >   The <span
            class="cmtt-10x-x-109">MATERIALIZE </span>operation saves the content of a dataset <span
            class="cmtt-10x-x-109">S1 </span>in a file, whose
                name is specified, and registers the saved dataset in the system to make
                it seamlessly usable in other GMQL queries. All datasets defined in a
                GMQL query are, by default, temporary; to see and preserve the content
                of any dataset generated during a GMQL query, the dataset must be
                materialized. Any dataset can be materialized, however the operation
                is time expensive; for best performance, materialize the relevant data
                only.
            </p><!--l. 848--><p class="noindent" >
            </p>
                <h3 class="sectionHead"><span class="titlemark">7   </span> <a
                id="x1-260007"></a>Full Biological Example</h3>
                    <!--l. 850--><p class="noindent" >This example uses a <span
            class="cmtt-10x-x-109">MAP </span>operation to count the peak regions in each ENCODE
                ChIP-seq sample that intersect with a gene promoter (i.e., regulatory region);
                then, in each sample it projects over the promoters with at least one intersecting
                peak and counts these promoters. Finally, it extracts the top-3 samples with the
                highest number of such promoters.


            </p>
                <div class="verbatim" id="verbatim-25">
                    HM_TF&#x00A0;=&#x00A0;SELECT(dataType&#x00A0;==&#x00A0;&#8217;ChipSeq&#8217;)&#x00A0;ENCODE;
                    &#x00A0;<br />
                    PROM&#x00A0;=&#x00A0;SELECT(annotation&#x00A0;==&#x00A0;&#8217;promoter&#8217;)&#x00A0;ANNOTATION;
                    &#x00A0;<br />PROM1&#x00A0;=&#x00A0;MAP()&#x00A0;PROM&#x00A0;HM_TF;
                    &#x00A0;<br />
                    PROM2&#x00A0;=&#x00A0;PROJECT(region:&#x00A0;count_PROM_HM_TF&#x00A0;&#x003E;=&#x00A0;1)&#x00A0;PROM1;
                    &#x00A0;<br />PROM3&#x00A0;=&#x00A0;EXTEND(prom_count&#x00A0;AS&#x00A0;COUNT())&#x00A0;PROM2;
                    &#x00A0;<br />
                    PROM_res&#x00A0;=&#x00A0;ORDER(DESC&#x00A0;prom_count;&#x00A0;meta_top:&#x00A0;3)&#x00A0;PROM3;
                    &#x00A0;<br />MATERIALIZE&#x00A0;PROM_res&#x00A0;INTO&#x00A0;res;
                </div>
                    <!--l. 859--><p class="nopar" >
                The query was executed over 2,423 samples including a total of 83,899,526
                peaks, which were mapped to 131,780 promoters, producing as result 29 GB of
                data; next, promoters with peaks were counted, and the 3 samples with more of
                such promoters were selected, having between 30K and 32K promoters
                each.
            </p>
                <hr class="figure" /><div class="figure"
            >


                <a
                id="x1-26001r6"></a>


                    <!--l. 869--><p class="noindent" ><img
            src="sources/metadata-result.png" alt="PIC"
            />
                <br /> </p><div class="caption"
            ><span class="id">Figure&#x00A0;6: </span><span
            class="content">Metadata excerpt of resulting samples</span></div><!--tex4ht:label?: x1-26001r6 -->


            </div><hr class="endfigure" />
                    <!--l. 875--><p class="indent" >   The <span
            class="cmtt-10x-x-109">PROM</span><span
            class="cmtt-10x-x-109">_res </span>result variable includes both regions and metadata; the former
                indicate the top 3 interesting promoter regions (that can be inspected using
                viewers, e.g., genome browsers), the latter allow tracing provenance of resulting
                samples and associating the extracted genomic information with the
                phenotypes. Fig. <a
            href="#x1-26001r6">6<!--tex4ht:ref: metadata --></a>
                shows 4 metadata attributes of the resulting samples: the
                <span
                class="cmtt-10x-x-109">order </span>of the sample, the <span
                class="cmtt-10x-x-109">antibody </span>and <span
                class="cmtt-10x-x-109">cell </span>type (normal embryonic
                stem cells) used in the experiment preparation, and the promoter region
                <span
                class="cmtt-10x-x-109">count</span>.
            </p>
                <h3 class="likesectionHead"><a
                id="x1-270007"></a>References</h3>
                    <!--l. 3--><p class="noindent" >
            </p><div class="thebibliography"><!--<bibitem><div class="js">-->
                <p class="bibitem" ><span class="biblabel">
                    [1]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><!--X1000=--><a
                id="X1000"></a>The  1000  Genomes  Consortium,  An  integrated  map  of  genetic
                    variation from 1,092 human genomes. <span
                class="cmti-10x-x-109">Nature</span>, 491, 56-65, November
                    2012.
                </p><!--</div></bibitem>
--> <!--<bibitem><div class="js">-->
                <p class="bibitem" ><span class="biblabel">
                    [2]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><!--XAU=--><a
                id="XAU"></a>F.  Afrati  et  al.,  Bounds  for  Overlapping  Interval  Join  of  Map
                    Reduce. <span
                class="cmti-10x-x-109">Workshop Proceedings, EDBT/ICDT</span>, 2015.
                </p><!--</div></bibitem>
--> <!--<bibitem><div class="js">-->
                <p class="bibitem" ><span class="biblabel">
                    [3]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><!--XFlink1=--><a
                id="XFlink1"></a>A.  Alexandrov  et  al.  The  Strathosphere  platform  for  big  data
                    analytics. <span
                class="cmti-10x-x-109">VLDB Journal </span>23(6), 939-964, 2014.
                </p><!--</div></bibitem>
--> <!--<bibitem><div class="js">-->
                <p class="bibitem" ><span class="biblabel">
                    [4]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><!--X[Flink-APACHE]=--><a
                id="X[Flink-APACHE]"></a>Apache Flink. http://flink.apache.org/
                </p><!--</div></bibitem>
--> <!--<bibitem><div class="js">-->
                <p class="bibitem" ><span class="biblabel">
                    [5]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><!--X[LUCENE]=--><a
                id="X[LUCENE]"></a>Apache Lucene. http://lucene.apache.org/core/


                </p><!--</div></bibitem>
--> <!--<bibitem><div class="js">-->
                <p class="bibitem" ><span class="biblabel">
                    [6]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><!--X[Pig-APACHE]=--><a
                id="X[Pig-APACHE]"></a>Apache Pig. http://pig.apache.org/
                </p><!--</div></bibitem>
--> <!--<bibitem><div class="js">-->
                <p class="bibitem" ><span class="biblabel">
                    [7]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><!--X[Spark-APACHE]=--><a
                id="X[Spark-APACHE]"></a>Apache Spark. http://spark.apache.org/
                </p><!--</div></bibitem>
--> <!--<bibitem><div class="js">-->
                <p class="bibitem" ><span class="biblabel">
                    [8]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><!--X[Banfa 2013]=--><a
                id="X[Banfa 2013]"></a>V.   Bafna   et   al.   Abstractions   for   genomics.<span
                class="cmti-10x-x-109">Commun.  ACM</span>,
                    56(1):83-93, 2013.
                </p><!--</div></bibitem>
--> <!--<bibitem><div class="js">-->
                <p class="bibitem" ><span class="biblabel">
                    [9]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><!--X[Cereda 2011]=--><a
                id="X[Cereda 2011]"></a>M. Cereda et al. GeCo++: a C++ library for genomic features
                    computation and annotation in the presence of variants. <span
                class="cmti-10x-x-109">Bioinformatics</span>,
                    27(9):1313-1315, 2011.
                </p><!--</div></bibitem>
--> <!--<bibitem><div class="js">-->
                <p class="bibitem" ><span class="biblabel">
                    [10]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><!--X[MapReduce]=--><a
                id="X[MapReduce]"></a>J. Ekanayake et al. MapReduce for data intensive scientific analyses.
                    In <span
                class="cmti-10x-x-109">Proc. IEEE eScience</span>, 277-284, 2008.
                </p><!--</div></bibitem>
--> <!--<bibitem><div class="js">-->
                <p class="bibitem" ><span class="biblabel">
                    [11]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><!--XFlink2=--><a
                id="XFlink2"></a>S. Ewen et al., Spinning fast iterative data flows. <span
                class="cmti-10x-x-109">PVLDB 2012</span>,
                    1268-1279.
                </p><!--</div></bibitem>
--> <!--<bibitem><div class="js">-->
                <p class="bibitem" ><span class="biblabel">
                    [12]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><!--X[ENCODE]=--><a
                id="X[ENCODE]"></a>ENCODE Project Consortium. An integrated encyclopedia of DNA
                    elements in the human genome. <span
                class="cmti-10x-x-109">Nature</span>, 489(7414):57-74, 2012.
                </p><!--</div></bibitem>
--> <!--<bibitem><div class="js">-->
                <p class="bibitem" ><span class="biblabel">
                    [13]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><!--X[Galaxy]=--><a
                id="X[Galaxy]"></a>Galaxy. http://galaxyproject.org/
                </p><!--</div></bibitem>
--> <!--<bibitem><div class="js">-->


                <p class="bibitem" ><span class="biblabel">
                    [14]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><!--XGuSe=--><a
                id="XGuSe"></a>H. Gunadhi and A. Segev. Query processing algorithms for temporal
                    intersection joins. In <span
                class="cmti-10x-x-109">Proc. IEEE ICDE</span>, 336-344, 1991.
                </p><!--</div></bibitem>
--> <!--<bibitem><div class="js">-->
                <p class="bibitem" ><span class="biblabel">
                    [15]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><!--X[Gray]=--><a
                id="X[Gray]"></a>T.  Hey  at  al.  Jim  Gray  on  eScience:  a  Transformed  Scientific
                    Method, In <span
                class="cmti-10x-x-109">The fourth paradigm. Data-intensive scientific discovery</span>,
                    Microsoft Research, Redmond, WA, XVII-XXXI, 2009.
                </p><!--</div></bibitem>
--> <!--<bibitem><div class="js">-->
                <p class="bibitem" ><span class="biblabel">
                    [16]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><!--X[Hadoop 2]=--><a
                id="X[Hadoop 2]"></a>Hadoop 2. http://hadoop.apache.org/docs/stable/
                </p><!--</div></bibitem>
--> <!--<bibitem><div class="js">-->
                <p class="bibitem" ><span class="biblabel">
                    [17]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><!--XFlink3=--><a
                id="XFlink3"></a>F. Hueske et al. Opening the black boxes in dataflow optimization.
                    <span
                    class="cmti-10x-x-109">PVLDB 2012</span>, 1256-1267.
                </p><!--</div></bibitem>
--> <!--<bibitem><div class="js">-->
                <p class="bibitem" ><span class="biblabel">
                    [18]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><!--XKent=--><a
                id="XKent"></a>W.J. Kent, The human genome browser at UCSC. <span
                class="cmti-10x-x-109">Genome Res.</span>,
                    2002; 12(6):996-1006.
                </p><!--</div></bibitem>
--> <!--<bibitem><div class="js">-->
                <p class="bibitem" ><span class="biblabel">
                    [19]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><!--X[Bafna 2014]=--><a
                id="X[Bafna 2014]"></a>C.  Kozanitis  et  al.  Using  Genome  Query  Language  to  uncover
                    genetic variation. <span
                class="cmti-10x-x-109">Bioinformatics </span>30(1):1-8, 2014.
                </p><!--</div></bibitem>
--> <!--<bibitem><div class="js">-->
                <p class="bibitem" ><span class="biblabel">
                    [20]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><!--X[GMQL]=--><a
                id="X[GMQL]"></a>M.  Masseroli,  P.  Pinoli,  F.  Venco,  A.  Kaitoua,  V.  Jalili,  F.
                    Palluzzi,  H.  Muller,  S.  Ceri.  GenoMetric  Query  Language:  A  novel
                    approach  to  large-scale  genomic  data  management.  <span
                class="cmti-10x-x-109">Bioinformatics</span>,
                    2015; 31(12):1881-1888.
                </p><!--</div></bibitem>
--> <!--<bibitem><div class="js">-->
                <p class="bibitem" ><span class="biblabel">
                    [21]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><!--X[BEDOps]=--><a
                id="X[BEDOps]"></a>S.  Neph,  et  al.  BEDOPS:  high-performance  genomic  feature
                    operations. <span
                class="cmti-10x-x-109">Bioinformatics</span>, 28(14):1919-1920, 2012.


                </p><!--</div></bibitem>
--> <!--<bibitem><div class="js">-->
                <p class="bibitem" ><span class="biblabel">
                    [22]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><!--X[Nordberg 2013]=--><a
                id="X[Nordberg 2013]"></a>H.  Nordberg  et  al.  BioPig:  a  Hadoop-based  analytic  toolkit  for
                    large-scale sequence data. <span
                class="cmti-10x-x-109">Bioinformatics</span>, 29(23):3014-3019, 2013.
                </p><!--</div></bibitem>
--> <!--<bibitem><div class="js">-->
                <p class="bibitem" ><span class="biblabel">
                    [23]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><!--X[PIG]=--><a
                id="X[PIG]"></a>C.  Olston  et  al.  Pig  Latin:  A  not-so-foreign  language  for  data
                    processing. <span
                class="cmti-10x-x-109">ACM-SIGMOD</span>, 1099-1110, 2008.
                </p><!--</div></bibitem>
--> <!--<bibitem><div class="js">-->
                <p class="bibitem" ><span class="biblabel">
                    [24]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><!--X[Ovaska 2013]=--><a
                id="X[Ovaska 2013]"></a>K.  Ovaska  et  al.  Genomic  Region  Operation  Kit  for  flexible
                    processing of deep sequencing data. <span
                class="cmti-10x-x-109">IEEE/ACM Trans. Comput. Biol.</span>
                    <span
                    class="cmti-10x-x-109">Bioinform</span>., 10(1):200-206, 2013.
                </p><!--</div></bibitem>
--> <!--<bibitem><div class="js">-->
                <p class="bibitem" ><span class="biblabel">
                    [25]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><!--X[Paradigm4]=--><a
                id="X[Paradigm4]"></a>Anonymous paper, Accelerating Bioinformatics Research with New
                    Software                                                                              for
                    Big Data to Knowledge (BD2K), Paradigm4 Inc., Waltham, MA, 1-16,
                    2015 (downloaded from: http://www.paradigm4.com/ on June 2015.)
                </p><!--</div></bibitem>
--> <!--<bibitem><div class="js">-->
                <p class="bibitem" ><span class="biblabel">
                    [26]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><!--X[BEDTools]=--><a
                id="X[BEDTools]"></a>A. R. Quinlan and I. M. Hall. BEDTools: a flexible suite of utilities
                    for comparing genomic features. <span
                class="cmti-10x-x-109">Bioinformatics</span>, 26(6):841-842, 2010.
                </p><!--</div></bibitem>
--> <!--<bibitem><div class="js">-->
                <p class="bibitem" ><span class="biblabel">
                    [27]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><!--X[Rohm 2009]=--><a
                id="X[Rohm 2009]"></a>U. Röhm and J. Blakeley. Data management for high-throughput
                    genomics. In <span
                class="cmti-10x-x-109">Proc. CDIR</span>, 1-10, 2009.
                </p><!--</div></bibitem>
--> <!--<bibitem><div class="js">-->
                <p class="bibitem" ><span class="biblabel">
                    [28]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><!--X[SeqPig 2013]=--><a
                id="X[SeqPig 2013]"></a>A. Schumacher et al. SeqPig: simple and scalable scripting for large
                    sequencing data sets in Hadoop. <span
                class="cmti-10x-x-109">Bioinformatics</span>, 30(1):119-120, 2014.
                </p><!--</div></bibitem>
--> <!--<bibitem><div class="js">-->


                <p class="bibitem" ><span class="biblabel">
                    [29]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><!--X[Hadoop]=--><a
                id="X[Hadoop]"></a>K. Shvachko et al. The Hadoop distributed file system. In <span
                class="cmti-10x-x-109">Proc.</span>
                    <span
                    class="cmti-10x-x-109">MSST</span>, 1-10, 2010.
                </p><!--</div></bibitem>
--> <!--<bibitem><div class="js">-->
                <p class="bibitem" ><span class="biblabel">
                    [30]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><!--XNEW=--><a
                id="XNEW"></a>L.D. Stein. The case for cloud computing in genome informatics.
                    <span
                    class="cmti-10x-x-109">Genome Biol</span>., 11(5):207, 2010.
                </p><!--</div></bibitem>
--> <!--<bibitem><div class="js">-->
                <p class="bibitem" ><span class="biblabel">
                    [31]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><!--X[Tata1]=--><a
                id="X[Tata1]"></a>S. Tata et al. Declarative Querying for Biological Sequences. In <span
                class="cmti-10x-x-109">Proc.</span>
                    <span
                    class="cmti-10x-x-109">IEEE ICDE</span>, 87:99, 2006.
                </p><!--</div></bibitem>
--> <!--<bibitem><div class="js">-->
                <p class="bibitem" ><span class="biblabel">
                    [32]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><!--X[Tata2]=--><a
                id="X[Tata2]"></a>S. Tata et al. Periscope/SQL: Interactive exploration of biological
                    sequence databases. In <span
                class="cmti-10x-x-109">Proc. VLDB</span>, 1406-1409, 2007.
                </p><!--</div></bibitem>
--> <!--<bibitem><div class="js">-->
                <p class="bibitem" ><span class="biblabel">
                    [33]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><!--X[Hadoop1]=--><a
                id="X[Hadoop1]"></a>R.  C.  Taylor.  An  overview  of  the  Hadoop  MapReduce  HBase
                    framework   and   its   current   applications   in   bioinformatics.<span
                class="cmti-10x-x-109">BMC</span>
                    <span
                    class="cmti-10x-x-109">Bioinformatics</span>, 11(12):S1, 2010.
                </p><!--</div></bibitem>
--> <!--<bibitem><div class="js">-->
                <p class="bibitem" ><span class="biblabel">
                    [34]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><!--XSpark3=--><a
                id="XSpark3"></a>R. Xin et al. Shark: SQL and Rich Analytics at Scale. In <span
                class="cmti-10x-x-109">Proc.</span>
                    <span
                    class="cmti-10x-x-109">ACM-SIGMOD</span>, June 2013.
                </p><!--</div></bibitem>
--> <!--<bibitem><div class="js">-->
                <p class="bibitem" ><span class="biblabel">
                    [35]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><!--X[TCGA]=--><a
                id="X[TCGA]"></a>J.  N.  Weinstein  et  al.  The  Cancer  Genome  Atlas  Pan-Cancer
                    analysis project. <span
                class="cmti-10x-x-109">Nat Genet</span>., 45(10):1113-1120, 2013.
                </p><!--</div></bibitem>
--> <!--<bibitem><div class="js">-->
                <p class="bibitem" ><span class="biblabel">
                    [36]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><!--X[SparkSeq]=--><a
                id="X[SparkSeq]"></a>M. S. Weiwiorka et al. SparkSeq: Fast, scalable and cloud-ready
                    tool for the interactive genomic data analysis with nucleotide precision.
                    <span
                    class="cmti-10x-x-109">Bioinformatics</span>, 30(18):2652-2653, 2014.


                </p><!--</div></bibitem>
--> <!--<bibitem><div class="js">-->
                <p class="bibitem" ><span class="biblabel">
                    [37]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><!--XSpark=--><a
                id="XSpark"></a>M. Zaharia et al. Resilient distributed datasets: A fault-tolerant
                    abstraction for in-memory cluster computing. In <span
                class="cmti-10x-x-109">Proc. USENIX</span>, 15-28,
                    2012.
                </p><!--</div></bibitem>
--> <!--<bibitem><div class="js">-->
                <p class="bibitem" ><span class="biblabel">
                    [38]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><!--XSpark2=--><a
                id="XSpark2"></a>M. Zaharia et al. Discretized Streams: Fault-Tolerant Streaming
                    Computation at Scale. In <span
                class="cmti-10x-x-109">Proc.M SOSP</span>, November 2013.
                </p>
                    <!--</div></bibitem>
--> </div>


                <div class="footnotes"><!--l. 51--><p class="indent" >     <!--<footnote>fn1x0=<div class="js">--><span class="footnote-mark"><a
                href="#fn1x0-bk" id="fn1x0">   <sup class="textsuperscript">1</sup></a></span><a
                href="http://www.genomicsengland.co.uk/" class="url" ><span
                class="cmtt-9">http://www.genomicsengland.co.uk/</span></a><!--</div></footnote>
--></p>
                        <!--l. 55--><p class="indent" >    <!--<footnote>fn2x0=<div class="js">--><span class="footnote-mark"><a
                    href="#fn2x0-bk" id="fn2x0">  <sup class="textsuperscript">2</sup></a></span><span
                    class="cmr-9">http://genomicsandhealth.org/</span><!--</div></footnote>
--></p>
                        <!--l. 55--><p class="indent" >      <!--<footnote>fn3x0=<div class="js">--><span class="footnote-mark"><a
                    href="#fn3x0-bk" id="fn3x0">    <sup class="textsuperscript">3</sup></a></span><span
                    class="cmr-9">http://ga4gh.org/#/api</span><!--</div></footnote>
--></p>
                        <!--l. 55--><p class="indent" >      <!--<footnote>fn4x0=<div class="js">--><span class="footnote-mark"><a
                    href="#fn4x0-bk" id="fn4x0">    <sup class="textsuperscript">4</sup></a></span><span
                    class="cmr-9">https://cloud.google.com/genomics/</span><!--</div></footnote>
--></p>
                        <!--l. 69--><p class="indent" >      <!--<footnote>fn5x0=<div class="js">--><span class="footnote-mark"><a
                    href="#fn5x0-bk" id="fn5x0">    <sup class="textsuperscript">5</sup></a></span><span
                    class="cmr-9">http://www.bioinformatics.deib.polimi.it/gendata/</span><!--</div></footnote>
--></p>
                        <!--l. 100--><p class="indent" >      <!--<footnote>fn6x0=<div class="js">--><span class="footnote-mark"><a
                    href="#fn6x0-bk" id="fn6x0">    <sup class="textsuperscript">6</sup></a></span><span
                    class="cmr-9">Finding ChIP-seq peaks in promoter regions; finding distal bindings in transcription</span>
                        <span
                        class="cmr-9">
                            regulatory regions; associating transcriptomics and epigenomics; finding somatic mutations in</span>
                        <span
                        class="cmr-9">exons.</span><!--</div></footnote>
--></p><!--l. 102--><p class="indent" > <!--<footnote>fn7x0=<div class="js">--><span class="footnote-mark"><a
                    href="#fn7x0-bk" id="fn7x0"> <sup class="textsuperscript">7</sup></a></span><span
                    class="cmr-9">Founded by this year&#8217;s Turing award Mike Stonembraker.</span><!--</div></footnote>
--></p>
                        <!--l. 125--><p class="indent" >      <!--<footnote>fn8x0=<div class="js">--><span class="footnote-mark"><a
                    href="#fn8x0-bk" id="fn8x0">    <sup class="textsuperscript">8</sup></a></span><span
                    class="cmr-9">
                        DNA can be abstracted as a string of billions of nucleotides (represented by the letters</span>
                        <span
                        class="cmtt-9">A,C,G,T</span><span
                        class="cmr-9">
                            ) enclosed within chromosomes (23 in humans), which are disconnected intervals of the</span>
                        <span
                        class="cmr-9">string.</span><!--</div></footnote>
--></p>
                        <!--l. 134--><p class="indent" >      <!--<footnote>fn9x0=<div class="js">--><span class="footnote-mark"><a
                    href="#fn9x0-bk" id="fn9x0">    <sup class="textsuperscript">9</sup></a></span><span
                    class="cmr-9">We currently store in </span><span
                    class="cmbx-9">GenData 2020 </span><span
                    class="cmr-9">most of ENCODE </span><span class="cite"><span
                    class="cmr-9">[</span><a
                    href="#X[ENCODE]"
onmouseover="tex4ht.body = tex4ht.XjVVENCODEjVV;
tex4ht.caption = '[ENCODE]';
return overlib(tex4ht.body, FULLHTML);"
onmouseout="nd();"
                    ><span
                    class="cmr-9">12</span></a><span
                    class="cmr-9">]</span></span> <span
                    class="cmr-9">and TCGA </span><span class="cite"><span
                    class="cmr-9">[</span><a
                    href="#X[TCGA]"
onmouseover="tex4ht.body = tex4ht.XjVVTCGAjVV;
tex4ht.caption = '[TCGA]';
return overlib(tex4ht.body, FULLHTML);"
onmouseout="nd();"
                    ><span
                    class="cmr-9">35</span></a><span
                    class="cmr-9">]</span></span> <span
                    class="cmr-9">processed</span>
                        <span
                        class="cmr-9">data.</span><!--</div></footnote>
--></p><!--l. 143--><p class="indent" > <!--<footnote>fn10x0=<div class="js">--><span class="footnote-mark"><a
                    href="#fn10x0-bk" id="fn10x0"> <sup class="textsuperscript">10</sup></a></span><span
                    class="cmr-9">Species are associated with their </span><span
                    class="cmti-9">reference genome</span><span
                    class="cmr-9">; DNA samples are aligned to these</span>
                        <span
                        class="cmr-9">
                            references, hence referred to the same system of coordinates; for humans, several references were</span>
                        <span
                        class="cmr-9">progressively defined, for instance </span><span
                        class="cmti-9">hg18</span><span
                        class="cmr-9">, </span><span
                        class="cmtt-9">hg19 </span><span
                        class="cmr-9">and </span><span
                        class="cmtt-9">hg20/GRCh38</span><span
                        class="cmr-9">.</span><!--</div></footnote>
--></p>
                        <!--l. 143--><p class="indent" >      <!--<footnote>fn11x0=<div class="js">--><span class="footnote-mark"><a
                    href="#fn11x0-bk" id="fn11x0">  <sup class="textsuperscript">11</sup></a></span><span
                    class="cmr-9">DNA is made of two strands rolled-up together in anti-parallel directions,</span>
                        <span
                        class="cmr-9">
                            i.e., they are read in opposite directions by the biomolecular machinery of the cell.</span>
                            <!--</div></footnote>
--></p>
                        <!--l. 147--><p class="indent" >      <!--<footnote>fn12x0=<div class="js">--><span class="footnote-mark"><a
                    href="#fn12x0-bk" id="fn12x0">  <sup class="textsuperscript">12</sup></a></span><span
                    class="cmr-9">According to the University of California at Santa Cruz (UCSC) notation, we use</span>
                        <span
                        class="cmti-9">0-based, half-open inter-base coordinates</span><span
                        class="cmr-9">, i.e., the considered genomic sequence is </span><img
                        src="manual0x.png" alt="[left,right)"  class="left" align="middle" /><span
                        class="cmr-9">. In</span>
                        <span
                        class="cmr-9">
                            this coordinate system, left and right ends can be identical (e.g., when the region represents an</span>
                        <span
                        class="cmr-9">
                            insertion in the reference), or consecutive (e.g., when the region represent a single nucleotide</span>
                        <span
                        class="cmr-9">polymorphism.</span><!--</div></footnote>
--></p>
                        <!--l. 181--><p class="indent" >      <!--<footnote>fn13x0=<div class="js">--><span class="footnote-mark"><a
                    href="#fn13x0-bk" id="fn13x0">  <sup class="textsuperscript">13</sup></a></span><span
                    class="cmr-9">Note that the quintuple </span><span
                    class="cmtt-9">(id, chr, left, right, strand) </span><span
                    class="cmr-9">is not a key of the region</span>
                        <span
                        class="cmr-9">
                            table (because a sample can have multiple regions with the same coordinates), and similarly the</span>
                        <span
                        class="cmr-9">pair </span><span
                        class="cmtt-9">(id, attribute) </span><span
                        class="cmr-9">is not a key of the metadata table (because metadata attributes can be</span>
                        <span
                        class="cmr-9">multi-valued).</span><!--</div></footnote>
--></p>
                        <!--l. 297--><p class="noindent" ><!--<footnote>fn14x0=<div class="js">--><span class="footnote-mark"><a
                    href="#fn14x0-bk" id="fn14x0">  <sup class="textsuperscript">14</sup></a></span><span
                    class="cmr-9">
                        Region predicates may include metadata attributes, but in such case they are legal iff</span>
                        <span
                        class="cmr-9">
                            the metadata attribute is single-valued and not null, and invalid otherwise; in such case,</span>
                        <span
                        class="cmr-9">
                            for a given sample, metadata attributes are equivalent to constant values.</span><!--</div></footnote>
--></p>
                        <!--l. 386--><p class="indent" >      <!--<footnote>fn15x0=<div class="js">--><span class="footnote-mark"><a
                    href="#fn15x0-bk" id="fn15x0">  <sup class="textsuperscript">15</sup></a></span><span
                    class="cmr-9">A syntactic variant (using the keywords </span><span
                    class="cmtt-9">ALLBUT</span><span
                    class="cmr-9">) allows to specify only the attributes</span>
                        <span
                        class="cmr-9">
                            that are removed from the result; this variant is very useful with datasets having many region</span>
                        <span
                        class="cmr-9">attributes.</span><!--</div></footnote>
--></p>
                        <!--l. 581--><p class="noindent" ><!--<footnote>fn16x0=<div class="js">--><span class="footnote-mark"><a
                    href="#fn16x0-bk" id="fn16x0">  <sup class="textsuperscript">16</sup></a></span><span
                    class="cmr-9">
                        When  regions  are  stranded,  cover  is  separately  applied  to  positive  and  negative</span>
                        <span
                        class="cmr-9">
                            strands; in such case, unstranded regions are accounted both as positive and negative.</span><!--</div></footnote>
--></p>
                        <!--l. 587--><p class="noindent" ><!--<footnote>fn17x0=<div class="js">--><span class="footnote-mark"><a
                    href="#fn17x0-bk" id="fn17x0">  <sup class="textsuperscript">17</sup></a></span><span
                    class="cmr-9">The keyword </span><span
                    class="cmtt-9">ANY </span><span
                    class="cmr-9">can be used as </span><span
                    class="cmtt-9">maxAcc</span><span
                    class="cmr-9">, and in this case no maximum is set (it</span>
                        <span
                        class="cmr-9">is equivalent to omitting the </span><span
                        class="cmtt-9">maxAcc </span><span
                        class="cmr-9">option); the keyword </span><span
                        class="cmtt-9">ALL </span><span
                        class="cmr-9">stands for the number of</span>
                        <span
                        class="cmr-9">samples in the operand, and can be used both for </span><span
                        class="cmtt-9">minAcc </span><span
                        class="cmr-9">and </span><span
                        class="cmtt-9">maxAcc</span><span
                        class="cmr-9">. Cases when </span><span
                        class="cmtt-9">maxAcc</span>
                        <span
                        class="cmr-9">is greater than </span><span
                        class="cmtt-9">ALL </span><span
                        class="cmr-9">are relevant when the input samples include overlapping regions.</span><!--</div></footnote>
--></p>
                        <!--l. 593--><p class="indent" >      <!--<footnote>fn18x0=<div class="js">--><span class="footnote-mark"><a
                    href="#fn18x0-bk" id="fn18x0">  <sup class="textsuperscript">18</sup></a></span><span
                    class="cmr-9">The </span><span
                    class="cmtt-9">JaccardIntersect </span><span
                    class="cmr-9">index is calculated as the ratio between the lengths of the</span>
                        <span
                        class="cmr-9">intersection and of the union of the contributing regions; the </span><span
                        class="cmtt-9">JaccardResult </span><span
                        class="cmr-9">index is calculated</span>
                        <span
                        class="cmr-9">
                            as the ratio between the lengths of the result and of the union of the contributing</span>
                        <span
                        class="cmr-9">regions.</span><!--</div></footnote>
--></p>
                        <!--l. 652--><p class="indent" >      <!--<footnote>fn19x0=<div class="js">--><span class="footnote-mark"><a
                    href="#fn19x0-bk" id="fn19x0">  <sup class="textsuperscript">19</sup></a></span><span
                    class="cmr-9">
                        Biologists typically consider the transposed matrix, because there are fewer experiments</span>
                        <span
                        class="cmr-9">
                            (on columns) than regions (on rows). Such matrix can be observed using heat maps, and its</span>
                        <span
                        class="cmr-9">rows and/or columns can be clustered to show patterns.</span><!--</div></footnote>
--></p>
                        <!--l. 662--><p class="indent" >      <!--<footnote>fn20x0=<div class="js">--><span class="footnote-mark"><a
                    href="#fn20x0-bk" id="fn20x0">  <sup class="textsuperscript">20</sup></a></span><span
                    class="cmr-9">
                        The implementation generates identifiers for the result by applying hash functions to</span>
                        <span
                        class="cmr-9">
                            the identifiers of operands, so that resulting identifiers are unique; they are identical if generated</span>
                        <span
                        class="cmr-9">multiple times for the same input samples.</span><!--</div></footnote>
--></p>
                        <!--l. 740--><p class="indent" >      <!--<footnote>fn21x0=<div class="js">--><span class="footnote-mark"><a
                    href="#fn21x0-bk" id="fn21x0">  <sup class="textsuperscript">21</sup></a></span><span
                    class="cmr-9">
                        Note that with our choice of interbase coordinates, intersecting regions have distance</span>
                        <span
                        class="cmr-9">
                            less than 0 and adjacent regions have distance equal to 0; if two regions belong to</span>
                        <span
                        class="cmr-9">
                            different chromosomes, their distance is undefined (and predicates based on distance</span>
                        <span
                        class="cmr-9">fail).</span><!--</div></footnote>
--></p>
                        <!--l. 743--><p class="noindent" ><!--<footnote>fn22x0=<div class="js">--><span class="footnote-mark"><a
                    href="#fn22x0-bk" id="fn22x0">  <sup class="textsuperscript">22</sup></a></span><span
                    class="cmr-9">Also: UPSTREAM, DOWNSTREAM.</span><!--</div></footnote>
--></p>
                        <!--l. 753--><p class="noindent" ><!--<footnote>fn23x0=<div class="js">--><span class="footnote-mark"><a
                    href="#fn23x0-bk" id="fn23x0">  <sup class="textsuperscript">23</sup></a></span><span
                    class="cmti-9">Upstream </span><span
                    class="cmr-9">and </span><span
                    class="cmti-9">downstream </span><span
                    class="cmr-9">are technical terms in genomics, and they are applied to</span>
                        <span
                        class="cmr-9">regions on the basis of their </span><span
                        class="cmti-9">strand</span><span
                        class="cmr-9">. For regions of the </span><span
                        class="cmti-9">positive strand </span><span
                        class="cmr-9">(or for </span><span
                        class="cmti-9">unstranded</span>
                        <span
                        class="cmti-9">regions</span><span
                        class="cmr-9">), </span><span
                        class="cmtt-9">UP </span><span
                        class="cmr-9">is true for those regions of the experiment whose right end is lower than the</span>
                        <span
                        class="cmr-9">left end of the anchor, and </span><span
                        class="cmtt-9">DOWN </span><span
                        class="cmr-9">is true for those regions of the experiment whose left</span>
                        <span
                        class="cmr-9">
                            end is higher than the right end of the anchor. (Remaining regions of the experiment are</span>
                        <span
                        class="cmr-9">overlapping with the anchor region.) For the </span><span
                        class="cmti-9">negative strand</span><span
                        class="cmr-9">, ends and disequations are</span>
                        <span
                        class="cmr-9">exchanged.</span><!--</div></footnote>
--></p>
                        <!--l. 754--><p class="noindent" ><!--<footnote>fn24x0=<div class="js">--><span class="footnote-mark"><a
                    href="#fn24x0-bk" id="fn24x0">  <sup class="textsuperscript">24</sup></a></span><span
                    class="cmr-9">Also: MINDIST, MINDISTANCE.</span><!--</div></footnote>
--></p>
                        <!--l. 757--><p class="noindent" ><!--<footnote>fn25x0=<div class="js">--><span class="footnote-mark"><a
                    href="#fn25x0-bk" id="fn25x0">  <sup class="textsuperscript">25</sup></a></span><span
                    class="cmr-9">Also: DIST </span><span
                    class="cmmi-9">&#x003C;</span><span
                    class="cmr-9">= </span><span
                    class="cmmi-9">N</span><span
                    class="cmr-9">, DISTANCE </span><span
                    class="cmmi-9">&#x003C;</span><span
                    class="cmr-9">= </span><span
                    class="cmmi-9">N</span><span
                    class="cmr-9">.</span><!--</div></footnote>
--></p>
                        <!--l. 760--><p class="noindent" ><!--<footnote>fn26x0=<div class="js">--><span class="footnote-mark"><a
                    href="#fn26x0-bk" id="fn26x0">  <sup class="textsuperscript">26</sup></a></span><span
                    class="cmr-9">DLE(-1) is true when the region of the experiment overlaps with the anchor region;</span>
                        <span
                        class="cmr-9">
                            DLE(0) is true when the region of the experiment is adjacent to or overlapping with the</span>
                        <span
                        class="cmr-9">anchor region.</span><!--</div></footnote>
--></p>
                        <!--l. 761--><p class="noindent" ><!--<footnote>fn27x0=<div class="js">--><span class="footnote-mark"><a
                    href="#fn27x0-bk" id="fn27x0">  <sup class="textsuperscript">27</sup></a></span><span
                    class="cmr-9">Also: DIST </span><span
                    class="cmmi-9">&#x003E;</span><span
                    class="cmr-9">= </span><span
                    class="cmmi-9">N</span><span
                    class="cmr-9">, DISTANCE </span><span
                    class="cmmi-9">&#x003E;</span><span
                    class="cmr-9">= </span><span
                    class="cmmi-9">N</span><span
                    class="cmr-9">.</span><!--</div></footnote>
--></p>
                        <!--l. 801--><p class="indent" >      <!--<footnote>fn28x0=<div class="js">--><span class="footnote-mark"><a
                    href="#fn28x0-bk" id="fn28x0">  <sup class="textsuperscript">28</sup></a></span><span
                    class="cmr-9">The two queries can be expressed as: </span><span
                    class="cmti-9">produce the minimum distance region iff its</span>
                        <span
                        class="cmti-9">distance is less than 100 bases </span><span
                        class="cmr-9">and </span><span
                        class="cmti-9">produce the minimum distance region after 100</span>
                        <span
                        class="cmti-9">bases</span><span
                        class="cmr-9">.</span><!--</div></footnote>
--></p><!--l. 813--><p class="indent" > <!--<footnote>fn29x0=<div class="js">--><span class="footnote-mark"><a
                    href="#fn29x0-bk" id="fn29x0"><sup class="textsuperscript">29</sup></a></span><span
                    class="cmr-9">If the operation applies to regions with the same strand, the result is also</span>
                        <span
                        class="cmr-9">
                            stranded in the same way; if it applies to regions with different strands, the result is not</span>
                        <span
                        class="cmr-9">stranded.</span><!--</div></footnote>
--></p><!--l. 828--><p class="indent" > <!--<footnote>fn30x0=<div class="js">--><span class="footnote-mark"><a
                    href="#fn30x0-bk" id="fn30x0"> <sup class="textsuperscript">30 </sup> </a></span><span
                    class="cmr-9">This query is used in the search of </span><span
                    class="cmti-9">enhancers</span><span
                    class="cmr-9">, i.e., parts of the genome which have an</span>
                        <span
                        class="cmr-9">important role in gene activation.</span><!--</div></footnote>
--></p>                                                                         </div>

                <section id="GroupA" class="group">
                    <h3>Group A</h3>
                    <div id="GroupASub1" class="subgroup" style="background: red;">
                        <h4>Group A Sub 1</h4>
                    </div>
                    <div id="GroupASub2" class="subgroup" style="background: blue;">
                        <h4>Group A Sub 2</h4>
                    </div>
                </section>
                <section id="GroupB" class="group">
                    <h3>Group B</h3>
                    <div id="GroupBSub1" class="subgroup">
                        <h4>Group B Sub 1</h4>
                    </div>
                    <div id="GroupBSub2" class="subgroup">
                        <h4>Group B Sub 2</h4>
                    </div>
                </section>
                <section id="GroupC" class="group">
                    <h3>Group C</h3>
                    <div id="GroupCSub1" class="subgroup">
                        <h4>Group C Sub 1</h4>
                    </div>
                    <div id="GroupCSub2" class="subgroup">
                        <h4>Group C Sub 2</h4>
                    </div>
                </section>

            </div>

        </div>

        <style type='text/css'>
        .group {
            background: yellow;
            width: 200px;
            height: 500px;
        }

        .group .subgroup {
            background: orange;
            width: 150px;
            height: 200px;
        }

        .fixed {
            position: fixed;
        }

        /* sidebar */
        .bs-docs-sidebar {
            padding-left: 20px;
            margin-top: 20px;
            margin-bottom: 20px;
        }

        /* all links */
        .bs-docs-sidebar .nav > li > a {
            color: #999;
            border-left: 2px solid transparent;
            padding: 4px 20px;
            font-size: 13px;
            font-weight: 400;
        }

        /* nested links */
        .bs-docs-sidebar .nav .nav > li > a {
            padding-top: 1px;
            padding-bottom: 1px;
            padding-left: 30px;
            font-size: 12px;
        }

        /* active & hover links */
        .bs-docs-sidebar .nav > .active > a,
        .bs-docs-sidebar .nav > li > a:hover,
        .bs-docs-sidebar .nav > li > a:focus {
            color: #563d7c;
            text-decoration: none;
            background-color: transparent;
            border-left-color: #563d7c;
        }

        /* all active links */
        .bs-docs-sidebar .nav > .active > a,
        .bs-docs-sidebar .nav > .active:hover > a,
        .bs-docs-sidebar .nav > .active:focus > a {
            font-weight: 700;
        }

        /* nested active links */
        .bs-docs-sidebar .nav .nav > .active > a,
        .bs-docs-sidebar .nav .nav > .active:hover > a,
        .bs-docs-sidebar .nav .nav > .active:focus > a {
            font-weight: 500;
        }

        /* hide inactive nested list */
        .bs-docs-sidebar .nav ul.nav {
            display: none;
        }

        /* show active nested list */
        .bs-docs-sidebar .nav > .active > ul.nav {
            display: block;
        }

        /*Header formatting */
        .MainContent {
            margin-top: 50px;
        }

        .sectionHead, .subsectionHead {
            padding-top: 50px;
            margin-top: -50px;
        }

        body {
            position: relative;
        }

        </style>
        @* <script>
        $('body').scrollspy({
        target: '.bs-docs-sidebar',
        offset: 40
        });
        </script>*@


    </body>
</html>
